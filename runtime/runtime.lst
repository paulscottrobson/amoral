
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D test=0 -q --m65c02 -o runtime.prg -L runtime.lst runtime.asm
; Sat Nov 21 07:21:27 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					test=0

;******  Processing input file: runtime.asm


;******  Processing file: macros.asm


;******  Return to file: runtime.asm

=$1000					BootAddr = $1000 							; Runtime loads at this address (e.g. Boot)
=$800					VarAddr = $800 								; Variable memory here (128 per 1/4k) PAGE BOUNDARY.
=8					VarPages = 8 								; Number of pages of variables (256 byte pages)
=$08					ZeroAddr = $08 								; Zero page goes here.
=0					test = 0									; test to run (default is build final)
=$800					Param1 = VarAddr 							; 0 parameter #1 of 2 for 2 param utility methods
=2050					Param2 = VarAddr+2 							; 1 parameter #2 of 3 for 3 param utility methods.
=2052					Param3 = VarAddr+4 							; 2 parameter #3 of 4 for 4 param utility methods
=2054					RandomSeed = VarAddr+6 						; 3 3rd var is random# seed.
=2056					SwapVar = VarAddr+8 						; 4 Var used for structure swap.
=$08					Reg16 = ZeroAddr 							; the current value register.
=10					Pctr = ZeroAddr+2 							; the program counter (e.g. the next instruction)
=12					temp0 = ZeroAddr+4 							; temporary registers
=14					temp1 = ZeroAddr+6
=16					ZeroAddrEnd = ZeroAddr+8 					; marks end of allocated space.
.1000	4c 00 10	jmp $1000			jmp 	BootAddr 					; test=0 what we normally get, no start address.
>1016	08						.byte 	ZeroAddr 					; Low byte of ZeroPage used.
>1017	10						.byte 	ZeroAddrEnd 				; High byte of ZeroPage used.
>1018	00 10						.word 	BootAddr 					; the address of boot
>101a	00 08						.word 	VarAddr 					; the address of the variables
>101c	4a 17						.word	RunTimeEnd 					; where the runtime ends (e.g. where code goes)
.101e					AllocMem:
>101e	00 00						.word 	$0000 						; address of allocatable memory (set up by compiler)
>1020	b1 02					.word 	EndRunPCode-* 							; offset to next entry
>1022	72 75 6e 2e 70 63 6f 64			.text 	"run.pcode:0",0 							; the text (must be lower case)
>102a	65 3a 30 00
>102e						.align 	2								; force to even boundary.

;******  Processing file: interpreter.asm

.102e					RunPCode:
.102e	86 09		stx $09				stx 	Reg16+1 					; save the current XA values.
.1030	85 08		sta $08				sta 	Reg16
.1032	68		pla				pla 								; pull the address into the PC
.1033	85 0a		sta $0a				sta 	Pctr
.1035	68		pla				pla
.1036	85 0b		sta $0b				sta 	Pctr+1
.1038	e6 0a		inc $0a			inc 	Pctr
.103a	d0 02		bne $103e		bne 	nocarry
.103c	e6 0b		inc $0b			inc 	1+(Pctr)
.103e					nocarry:
.103e					ExecLoop:
.103e	a0 00		ldy #$00			ldy 	#0							; get the next instruction
.1040	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1042	e6 0a		inc $0a			inc 	Pctr
.1044	d0 02		bne $1048		bne 	nocarry
.1046	e6 0b		inc $0b			inc 	1+(Pctr)
.1048					nocarry:
.1048	0a		asl a				asl 	a 							; shift bit 7 into carry.
.1049	b0 30		bcs $107b			bcs 	CommandHandler 				; 80-FF it's a command
.104b	85 0c		sta $0c				sta 	temp0 						; construct the call address in temp0
.104d	b1 0a		lda ($0a),y			lda 	(PCtr),y 					; get the MSB
.104f	85 0d		sta $0d				sta 	temp0+1
.1051	e6 0a		inc $0a			inc 	Pctr
.1053	d0 02		bne $1057		bne 	nocarry
.1055	e6 0b		inc $0b			inc 	1+(Pctr)
.1057					nocarry:
.1057	a5 0a		lda $0a				lda 	Pctr 						; save PCTR on 6502 stack
.1059	48		pha				pha
.105a	a5 0b		lda $0b				lda 	Pctr+1
.105c	48		pha				pha
.105d	a5 08		lda $08				lda 	Reg16 						; restore Reg16 into XA
.105f	a6 09		ldx $09				ldx 	Reg16+1
.1061	20 71 10	jsr $1071			jsr 	CallTemp0 					; call the routine as 6502 code.
.1064	86 09		stx $09				stx 	Reg16+1 					; save Reg16 back
.1066	85 08		sta $08				sta 	Reg16
.1068	68		pla				pla 								; restore the program counter
.1069	85 0b		sta $0b				sta 	Pctr+1
.106b	68		pla				pla
.106c	85 0a		sta $0a				sta 	Pctr
.106e	4c 3e 10	jmp $103e			jmp 	ExecLoop 					; and go round again.
.1071					CallTemp0:
.1071	6c 0c 00	jmp ($000c)			jmp 	(temp0)
.1074					Command_Return:
.1074	a5 08		lda $08				lda 	Reg16 						; get XA back
.1076	a6 09		ldx $09				ldx 	Reg16+1
.1078	6c 0a 00	jmp ($000a)			jmp 	(Pctr)						; and go back to the caller.
.107b					CommandHandler:
.107b	6a		ror a				ror 	a 							; patch it back so it has the full opcode.
.107c	a8		tay				tay  								; save it in Y for use by the commands.
.107d	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a unary operation.
.107f	b0 05		bcs $1086			bcs 	_CHIsUnary
.1081	29 0f		and #$0f			and 	#$0F 						; get the command number out.
.1083	4c 8a 10	jmp $108a			jmp 	_CHCall 					; go do the call
.1086					_CHIsUnary:
.1086	29 0f		and #$0f			and 	#$0F 						; this is the unary command number
.1088	09 10		ora #$10			ora 	#$10 						; mapped onto $10-$1F
.108a					_CHCall:
.108a	0a		asl a				asl 	a 							; now offset in the jump table and into X
.108b	aa		tax				tax
.108c	bd 9c 10	lda $109c,x			lda 	JumpTable,x 				; copy the jump table vectors into temp0
.108f	85 0c		sta $0c				sta 	temp0
.1091	bd 9d 10	lda $109d,x			lda 	JumpTable+1,x
.1094	85 0d		sta $0d				sta 	temp0+1
.1096	6c 0c 00	jmp ($000c)			jmp 	(temp0)						; and go there to execute with the opcode in Y.
.1099					OpcodeError:
.1099	a2 ee		ldx #$ee			ldx 	#$EE 						; EE = Error :)
>109b	db					.byte 	$DB
.109c					JumpTable:

;******  Processing file: generated/jumptable.inc

>109c	dc 10					.word LoadHandler              ; $80 LDR
>109e	21 11					.word Andhandler               ; $81 AND
>10a0	33 11					.word Orhandler                ; $82 ORR
>10a2	45 11					.word Xorhandler               ; $83 XOR
>10a4	fb 10					.word Addhandler               ; $84 ADD
>10a6	0e 11					.word Subhandler               ; $85 SUB
>10a8	4c 12					.word MultiplyHandler          ; $86 MLT
>10aa	81 12					.word DivideHandler            ; $87 DIV
>10ac	9a 12					.word ModulusHandler           ; $88 MOD
>10ae	57 11					.word DecVarHandler            ; $89 DCV
>10b0	ea 10					.word StoreHandler             ; $8a STR
>10b2	ea 11					.word Branch_Always            ; $8b BRA
>10b4	f9 11					.word Branch_Zero              ; $8c BEQ
>10b6	01 12					.word Branch_NonZero           ; $8d BNE
>10b8	15 12					.word Branch_Minus             ; $8e BMI
>10ba	1b 12					.word Branch_Positive          ; $8f BPL
>10bc	21 12					.word Inc_Unary                ; $f0 INC
>10be	2a 12					.word Dec_Unary                ; $f1 DEC
>10c0	35 12					.word Shl_Unary                ; $f2 SHL
>10c2	3c 12					.word Shr_Unary                ; $f3 SHR
>10c4	43 12					.word Clr_Unary                ; $f4 CLR
>10c6	74 10					.word Command_Return           ; $f5 RET
>10c8	99 10					.word OpcodeError              ; $f6 ?
>10ca	99 10					.word OpcodeError              ; $f7 ?
>10cc	99 10					.word OpcodeError              ; $f8 ?
>10ce	99 10					.word OpcodeError              ; $f9 ?
>10d0	99 10					.word OpcodeError              ; $fa ?
>10d2	99 10					.word OpcodeError              ; $fb ?
>10d4	99 10					.word OpcodeError              ; $fc ?
>10d6	99 10					.word OpcodeError              ; $fd ?
>10d8	99 10					.word OpcodeError              ; $fe ?
>10da	99 10					.word OpcodeError              ; $ff ?

;******  Return to file: interpreter.asm


;******  Return to file: runtime.asm


;******  Processing file: commands.asm

.10dc					LoadHandler:
.10dc	20 6d 11	jsr $116d			jsr 	EvaluateValue 				; temp0 = target value.
.10df	a5 0c		lda $0c				lda 	temp0						; copy value into register
.10e1	85 08		sta $08				sta 	Reg16
.10e3	a5 0d		lda $0d				lda 	temp0+1
.10e5	85 09		sta $09				sta 	Reg16+1
.10e7	4c 3e 10	jmp $103e			jmp 	ExecLoop
.10ea					StoreHandler:
.10ea	20 a2 11	jsr $11a2			jsr 	EvaluateAddress 			; temp0 = target address.
.10ed	a0 00		ldy #$00			ldy 	#0							; write register out
.10ef	a5 08		lda $08				lda 	Reg16
.10f1	91 0c		sta ($0c),y			sta 	(temp0),y
.10f3	a5 09		lda $09				lda 	Reg16+1
.10f5	c8		iny				iny
.10f6	91 0c		sta ($0c),y			sta 	(temp0),y
.10f8	4c 3e 10	jmp $103e			jmp 	ExecLoop
.10fb					Addhandler:
.10fb	20 6d 11	jsr $116d			jsr 	EvaluateValue
.10fe	18		clc				clc
.10ff	a5 08		lda $08				lda 	Reg16
.1101	65 0c		adc $0c				adc 	temp0
.1103	85 08		sta $08				sta 	Reg16
.1105	a5 09		lda $09				lda 	Reg16+1
.1107	65 0d		adc $0d				adc 	temp0+1
.1109	85 09		sta $09				sta 	Reg16+1
.110b	4c 3e 10	jmp $103e			jmp 	ExecLoop
.110e					Subhandler:
.110e	20 6d 11	jsr $116d			jsr 	EvaluateValue
.1111	38		sec				sec
.1112	a5 08		lda $08				lda 	Reg16
.1114	e5 0c		sbc $0c				sbc 	temp0
.1116	85 08		sta $08				sta 	Reg16
.1118	a5 09		lda $09				lda 	Reg16+1
.111a	e5 0d		sbc $0d				sbc 	temp0+1
.111c	85 09		sta $09				sta 	Reg16+1
.111e	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1121					Andhandler:
.1121	20 6d 11	jsr $116d			jsr 	EvaluateValue
.1124	a5 08		lda $08				lda 	Reg16
.1126	25 0c		and $0c				and 	temp0
.1128	85 08		sta $08				sta 	Reg16
.112a	a5 09		lda $09				lda 	Reg16+1
.112c	25 0d		and $0d				and 	temp0+1
.112e	85 09		sta $09				sta 	Reg16+1
.1130	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1133					Orhandler:
.1133	20 6d 11	jsr $116d			jsr 	EvaluateValue
.1136	a5 08		lda $08				lda 	Reg16
.1138	05 0c		ora $0c				ora 	temp0
.113a	85 08		sta $08				sta 	Reg16
.113c	a5 09		lda $09				lda 	Reg16+1
.113e	05 0d		ora $0d				ora 	temp0+1
.1140	85 09		sta $09				sta 	Reg16+1
.1142	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1145					Xorhandler:
.1145	20 6d 11	jsr $116d			jsr 	EvaluateValue
.1148	a5 08		lda $08				lda 	Reg16
.114a	45 0c		eor $0c				eor 	temp0
.114c	85 08		sta $08				sta 	Reg16
.114e	a5 09		lda $09				lda 	Reg16+1
.1150	45 0d		eor $0d				eor 	temp0+1
.1152	85 09		sta $09				sta 	Reg16+1
.1154	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1157					DecVarHandler:
.1157	20 a2 11	jsr $11a2			jsr 	EvaluateAddress 			; temp0 = target address.
.115a	a0 00		ldy #$00			ldy 	#0
.115c	38		sec				sec
.115d	b1 0c		lda ($0c),y			lda 	(temp0),y 					; subtract one from the address
.115f	e9 01		sbc #$01			sbc 	#1
.1161	91 0c		sta ($0c),y			sta 	(temp0),y
.1163	c8		iny				iny
.1164	b1 0c		lda ($0c),y			lda 	(temp0),y
.1166	e9 00		sbc #$00			sbc 	#0
.1168	91 0c		sta ($0c),y			sta 	(temp0),y
.116a	4c 3e 10	jmp $103e			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: support.asm

.116d					EvaluateValue:
.116d	98		tya				tya 								; get EAC part and save in X
.116e	29 70		and #$70			and 	#$70
.1170	aa		tax				tax
.1171	c9 20		cmp #$20			cmp 	#$20 						; check if 00,01 if so it is variable or absolute
.1173	b0 1d		bcs $1192			bcs 	_EDMemory
.1175	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1177	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1179	85 0c		sta $0c				sta 	temp0
.117b	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.117d	e6 0a		inc $0a			inc 	Pctr
.117f	d0 02		bne $1183		bne 	nocarry
.1181	e6 0b		inc $0b			inc 	1+(Pctr)
.1183					nocarry:
.1183	e0 00		cpx #$00			cpx 	#0 							; if it is 000 then it is a one byte
.1185	f0 0a		beq $1191			beq 	_EACalcValue
.1187	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.1189	85 0d		sta $0d				sta 	temp0+1
.118b	e6 0a		inc $0a			inc 	Pctr
.118d	d0 02		bne $1191		bne 	nocarry
.118f	e6 0b		inc $0b			inc 	1+(Pctr)
.1191					nocarry:
.1191					_EACalcValue:
.1191	60		rts				rts
.1192					_EDMemory:
.1192	20 a2 11	jsr $11a2			jsr	 	EvaluateAddress 			; evaluate the address.
.1195	a0 00		ldy #$00			ldy 	#0 							; 16 bit load indirect (temp0) => temp0
.1197	b1 0c		lda ($0c),y			lda 	(temp0),y
.1199	aa		tax				tax
.119a	c8		iny				iny
.119b	b1 0c		lda ($0c),y			lda 	(temp0),y
.119d	86 0c		stx $0c				stx 	temp0
.119f	85 0d		sta $0d				sta 	temp0+1
.11a1	60		rts				rts
.11a2					EvaluateAddress:
.11a2	98		tya				tya 								; get EAC part of opcode.
.11a3	29 70		and #$70			and 	#$70
.11a5	c9 40		cmp #$40			cmp 	#$40 						; is it an absolute address
.11a7	f0 29		beq $11d2			beq 	_EAAbsolute
.11a9	aa		tax				tax 								; save in X
.11aa	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.11ac	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11ae	85 0c		sta $0c				sta 	temp0
.11b0	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.11b2	e6 0a		inc $0a			inc 	Pctr
.11b4	d0 02		bne $11b8		bne 	nocarry
.11b6	e6 0b		inc $0b			inc 	1+(Pctr)
.11b8					nocarry:
.11b8	e0 20		cpx #$20			cpx 	#$20 						; if it is 010 then it is a one byte
.11ba	f0 0a		beq $11c6			beq 	_EACalcVarAddress
.11bc	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.11be	85 0d		sta $0d				sta 	temp0+1
.11c0	e6 0a		inc $0a			inc 	Pctr
.11c2	d0 02		bne $11c6		bne 	nocarry
.11c4	e6 0b		inc $0b			inc 	1+(Pctr)
.11c6					nocarry:
.11c6					_EACalcVarAddress:
.11c6	06 0c		asl $0c				asl 	temp0 						; double the variable number
.11c8	26 0d		rol $0d				rol 	temp0+1
.11ca	18		clc				clc 								; add the page address of variable data on.
.11cb	a5 0d		lda $0d				lda 	temp0+1
.11cd	69 08		adc #$08			adc 	#VarAddr/256
.11cf	85 0d		sta $0d				sta 	temp0+1
.11d1	60		rts				rts
.11d2					_EAAbsolute:
.11d2	a0 00		ldy #$00			ldy 	#0 							; get the address into temp0
.11d4	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11d6	85 0c		sta $0c				sta 	temp0
.11d8	c8		iny				iny
.11d9	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11db	85 0d		sta $0d				sta 	temp0+1
.11dd					ReturnBump2
.11dd	e6 0a		inc $0a			inc 	Pctr
.11df	d0 02		bne $11e3		bne 	nocarry
.11e1	e6 0b		inc $0b			inc 	1+(Pctr)
.11e3					nocarry:
.11e3					ReturnBump1:
.11e3	e6 0a		inc $0a			inc 	Pctr
.11e5	d0 02		bne $11e9		bne 	nocarry
.11e7	e6 0b		inc $0b			inc 	1+(Pctr)
.11e9					nocarry:
.11e9	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: branches.asm

.11ea					Branch_Always:
.11ea	a0 00		ldy #$00			ldy 	#0
.11ec	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11ee	aa		tax				tax
.11ef	c8		iny				iny
.11f0	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11f2	85 0b		sta $0b				sta 	Pctr+1
.11f4	86 0a		stx $0a				stx 	Pctr
.11f6	4c 3e 10	jmp $103e			jmp 	ExecLoop
.11f9					Branch_Zero:
.11f9	a5 08		lda $08				lda 	Reg16
.11fb	05 09		ora $09				ora 	Reg16+1
.11fd	f0 eb		beq $11ea			beq 	Branch_Always
.11ff	d0 06		bne $1207			bne 	Branch_Fail
.1201					Branch_NonZero:
.1201	a5 08		lda $08				lda 	Reg16
.1203	05 09		ora $09				ora 	Reg16+1
.1205	d0 e3		bne $11ea			bne 	Branch_Always
.1207					Branch_Fail:
.1207	18		clc				clc
.1208	a5 0a		lda $0a				lda 	Pctr
.120a	69 02		adc #$02			adc 	#2
.120c	85 0a		sta $0a				sta 	Pctr
.120e	d0 02		bne $1212			bne 	_BFNoCarry
.1210	e6 0b		inc $0b				inc 	Pctr+1
.1212					_BFNoCarry:
.1212	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1215					Branch_Minus:
.1215	a5 09		lda $09				lda 	Reg16+1
.1217	30 d1		bmi $11ea			bmi 	Branch_Always
.1219	10 ec		bpl $1207			bpl 	Branch_Fail
.121b					Branch_Positive:
.121b	a5 09		lda $09				lda 	Reg16+1
.121d	10 cb		bpl $11ea			bpl 	Branch_Always
.121f	30 e6		bmi $1207			bmi 	Branch_Fail

;******  Return to file: runtime.asm


;******  Processing file: unary.asm

.1221					Inc_Unary:
.1221	e6 08		inc $08			inc 	Reg16
.1223	d0 02		bne $1227		bne 	nocarry
.1225	e6 09		inc $09			inc 	1+(Reg16)
.1227					nocarry:
.1227	4c 3e 10	jmp $103e			jmp 	ExecLoop
.122a					Dec_Unary:
.122a	a5 08		lda $08			lda 	Reg16
.122c	d0 02		bne $1230		bne 	noborrow
.122e	c6 09		dec $09			dec 	1+(Reg16)
.1230					noborrow:
.1230	c6 08		dec $08			dec 	Reg16
.1232	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1235					Shl_Unary:
.1235	06 08		asl $08				asl 	Reg16
.1237	26 09		rol $09				rol 	Reg16+1
.1239	4c 3e 10	jmp $103e			jmp 	ExecLoop
.123c					Shr_Unary:
.123c	46 09		lsr $09				lsr 	Reg16+1
.123e	66 08		ror $08				ror 	Reg16
.1240	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1243					Clr_Unary:
.1243	a9 00		lda #$00			lda 	#0
.1245	85 08		sta $08				sta		Reg16
.1247	85 09		sta $09				sta 	Reg16+1
.1249	4c 3e 10	jmp $103e			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: multiply.asm

.124c					MultiplyHandler:
.124c	20 6d 11	jsr $116d			jsr 	EvaluateValue 				; temp0 = target value.
.124f	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.1251	85 0e		sta $0e				sta 	temp1
.1253	a5 09		lda $09				lda	 	Reg16+1
.1255	85 0f		sta $0f				sta 	temp1+1
.1257	20 5d 12	jsr $125d			jsr 	Multiply 					; Reg16 := temp0 * temp1
.125a	4c 3e 10	jmp $103e			jmp 	ExecLoop
.125d					Multiply:
.125d	a9 00		lda #$00			lda 	#0 							; zero total.
.125f	85 08		sta $08				sta 	Reg16
.1261	85 09		sta $09				sta 	Reg16+1
.1263					_MultLoop:
.1263	46 0d		lsr $0d				lsr 	temp0+1
.1265	66 0c		ror $0c				ror 	temp0
.1267	90 0d		bcc $1276			bcc 	_MultNoAdd
.1269	18		clc				clc
.126a	a5 0e		lda $0e				lda 	temp1
.126c	65 08		adc $08				adc 	Reg16
.126e	85 08		sta $08				sta 	Reg16
.1270	a5 0f		lda $0f				lda 	temp1+1
.1272	65 09		adc $09				adc 	Reg16+1
.1274	85 09		sta $09				sta 	Reg16+1
.1276					_MultNoAdd:
.1276	06 0e		asl $0e				asl 	temp1
.1278	26 0f		rol $0f				rol 	temp1+1
.127a	a5 0c		lda $0c				lda 	temp0
.127c	05 0d		ora $0d				ora 	temp0+1
.127e	d0 e3		bne $1263			bne 	_MultLoop
.1280	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: divide.asm

.1281					DivideHandler:
.1281	20 6d 11	jsr $116d			jsr 	EvaluateValue 				; temp0 = target value.
.1284	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.1286	85 0e		sta $0e				sta 	temp1
.1288	a5 09		lda $09				lda	 	Reg16+1
.128a	85 0f		sta $0f				sta 	temp1+1
.128c	20 ab 12	jsr $12ab			jsr 	Divide 						; temp1 := temp1 / temp0
.128f	a5 0e		lda $0e				lda 	temp1 						; copy result into register
.1291	85 08		sta $08				sta 	Reg16
.1293	a5 0f		lda $0f				lda 	temp1+1
.1295	85 09		sta $09				sta 	Reg16+1
.1297	4c 3e 10	jmp $103e			jmp 	ExecLoop
.129a					ModulusHandler:
.129a	20 6d 11	jsr $116d			jsr 	EvaluateValue 				; temp0 = target value.
.129d	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.129f	85 0e		sta $0e				sta 	temp1
.12a1	a5 09		lda $09				lda	 	Reg16+1
.12a3	85 0f		sta $0f				sta 	temp1+1
.12a5	20 ab 12	jsr $12ab			jsr 	Divide 						; temp1 := temp1 / temp0, mod => Reg16
.12a8	4c 3e 10	jmp $103e			jmp 	ExecLoop
.12ab					Divide:
.12ab	a9 00		lda #$00			lda 	#0 							; set A = 0
.12ad	85 08		sta $08				sta 	Reg16
.12af	85 09		sta $09				sta 	Reg16+1
.12b1	a0 10		ldy #$10			ldy 	#16 						; loop round 16 times.
.12b3					_DivLoop:
.12b3	06 0e		asl $0e				asl 	temp1 						; shift QA left. Q first
.12b5	26 0f		rol $0f				rol 	temp1+1
.12b7	26 08		rol $08				rol 	Reg16 						; shift A left carrying in.
.12b9	26 09		rol $09				rol 	Reg16+1
.12bb	38		sec				sec 								; calculate A-M, result in XA/C
.12bc	a5 08		lda $08				lda 	Reg16
.12be	e5 0c		sbc $0c				sbc 	temp0
.12c0	aa		tax				tax
.12c1	a5 09		lda $09				lda 	Reg16+1
.12c3	e5 0d		sbc $0d				sbc 	temp0+1
.12c5	90 06		bcc $12cd			bcc 	_DivNoUpdate 				; if A >= M then store result and set Q bit 0.
.12c7	85 09		sta $09				sta 	Reg16+1
.12c9	86 08		stx $08				stx 	Reg16
.12cb	e6 0e		inc $0e				inc 	temp1 						; we know it is even.
.12cd					_DivNoUpdate:
.12cd	88		dey				dey
.12ce	d0 e3		bne $12b3			bne 	_DivLoop
.12d0	60		rts				rts

;******  Return to file: runtime.asm

.12d1					EndRunPCode:

;******  Processing file: muldiv.asm

>12d1	40 00					.word 	EndStringConstant-* 							; offset to next entry
>12d3	73 74 72 69 6e 67 2e 63			.text 	"string.constant:0",0 							; the text (must be lower case)
>12db	6f 6e 73 74 61 6e 74 3a 30 00
>12e5						.align 	2								; force to even boundary.
.12e6					StringConstant:
.12e6	68		pla				pla 										; pull address and save in temp0
.12e7	85 0c		sta $0c				sta 	temp0
.12e9	68		pla				pla
.12ea	85 0d		sta $0d				sta 	temp0+1
.12ec	e6 0c		inc $0c			inc 	temp0
.12ee	d0 02		bne $12f2		bne 	nocarry
.12f0	e6 0d		inc $0d			inc 	1+(temp0)
.12f2					nocarry:
.12f2	a0 00		ldy #$00			ldy 	#0 									; figure out the end of the string.
.12f4	b1 0c		lda ($0c),y	_SCEnd:	lda 	(temp0),y
.12f6	c8		iny				iny
.12f7	c9 00		cmp #$00			cmp 	#0
.12f9	d0 f9		bne $12f4			bne 	_SCEnd
.12fb	18		clc				clc 										; add Y to temp0, to continue, while putting
.12fc	84 0e		sty $0e				sty 	temp1 								; original value into XY
.12fe	18		clc				clc
.12ff	a5 0c		lda $0c				lda 	temp0
.1301	a8		tay				tay
.1302	65 0e		adc $0e				adc 	temp1
.1304	85 0c		sta $0c				sta 	temp0
.1306	a5 0d		lda $0d				lda 	temp0+1
.1308	aa		tax				tax
.1309	69 00		adc #$00			adc 	#0
.130b	85 0d		sta $0d				sta 	temp0+1
.130d	98		tya				tya 										; value now in XA
.130e	6c 0c 00	jmp ($000c)			jmp 	(temp0)								; and continue.
.1311					EndStringConstant:
>1311	22 00					.word 	EndMultiplyImmediate-* 							; offset to next entry
>1313	6d 75 6c 74 69 70 6c 79			.text 	"multiply.immediate:0",0 							; the text (must be lower case)
>131b	2e 69 6d 6d 65 64 69 61 74 65 3a 30 00
>1328						.align 	2								; force to even boundary.
.1328					MultiplyImmediate:
.1328	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.132b	20 5d 12	jsr $125d			jsr 	Multiply
.132e	a5 08		lda $08				lda 	Reg16
.1330	a6 09		ldx $09				ldx 	Reg16+1
.1332	60		rts				rts
.1333					EndMultiplyImmediate:
>1333	25 00					.word 	EndMultiplyAbsolute-* 							; offset to next entry
>1335	6d 75 6c 74 69 70 6c 79			.text 	"multiply.absolute:0",0 							; the text (must be lower case)
>133d	2e 61 62 73 6f 6c 75 74 65 3a 30 00
>1349						.align 	2								; force to even boundary.
.134a					MultiplyAbsolute:
.134a	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.134d	20 07 14	jsr $1407			jsr 	LoadIndirectTemp0
.1350	20 5d 12	jsr $125d			jsr 	Multiply
.1353	a5 08		lda $08				lda 	Reg16
.1355	a6 09		ldx $09				ldx 	Reg16+1
.1357	60		rts				rts
.1358					EndMultiplyAbsolute:
>1358	21 00					.word 	EndDivideImmediate-* 							; offset to next entry
>135a	64 69 76 69 64 65 2e 69			.text 	"divide.immediate:0",0 							; the text (must be lower case)
>1362	6d 6d 65 64 69 61 74 65 3a 30 00
>136d						.align 	2								; force to even boundary.
.136e					DivideImmediate:
.136e	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.1371	20 ab 12	jsr $12ab			jsr 	Divide
.1374	a5 0e		lda $0e				lda 	temp1
.1376	a6 0f		ldx $0f				ldx 	temp1+1
.1378	60		rts				rts
.1379					EndDivideImmediate:
>1379	23 00					.word 	EndDivideAbsolute-* 							; offset to next entry
>137b	64 69 76 69 64 65 2e 61			.text 	"divide.absolute:0",0 							; the text (must be lower case)
>1383	62 73 6f 6c 75 74 65 3a 30 00
>138d						.align 	2								; force to even boundary.
.138e					DivideAbsolute:
.138e	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.1391	20 07 14	jsr $1407			jsr 	LoadIndirectTemp0
.1394	20 ab 12	jsr $12ab			jsr 	Divide
.1397	a5 0e		lda $0e				lda 	temp1
.1399	a6 0f		ldx $0f				ldx 	temp1+1
.139b	60		rts				rts
.139c					EndDivideAbsolute:
>139c	21 00					.word 	EndModulusImmediate-* 							; offset to next entry
>139e	6d 6f 64 75 6c 75 73 2e			.text 	"modulus.immediate:0",0 							; the text (must be lower case)
>13a6	69 6d 6d 65 64 69 61 74 65 3a 30 00
>13b2						.align 	2								; force to even boundary.
.13b2					ModulusImmediate:
.13b2	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.13b5	20 ab 12	jsr $12ab			jsr 	Divide
.13b8	a5 08		lda $08				lda 	Reg16
.13ba	a6 09		ldx $09				ldx 	Reg16+1
.13bc	60		rts				rts
.13bd					EndModulusImmediate:
>13bd	57 00					.word 	EndMulDivContent-* 							; offset to next entry
>13bf	6d 6f 64 75 6c 75 73 2e			.text 	"modulus.absolute:0",0 							; the text (must be lower case)
>13c7	61 62 73 6f 6c 75 74 65 3a 30 00
>13d2						.align 	2								; force to even boundary.
.13d2					ModulusAbsolute:
.13d2	20 e0 13	jsr $13e0			jsr 	SaveXTemp1GetTemp0
.13d5	20 07 14	jsr $1407			jsr 	LoadIndirectTemp0
.13d8	20 ab 12	jsr $12ab			jsr 	Divide
.13db	a5 08		lda $08				lda 	Reg16
.13dd	a6 09		ldx $09				ldx 	Reg16+1
.13df	60		rts				rts
.13e0					SaveXTemp1GetTemp0:
.13e0	85 0e		sta $0e				sta 	temp1 						; write XA out.
.13e2	86 0f		stx $0f				stx 	temp1+1
.13e4	ba		tsx				tsx 								; get stack pointer so we can access return two up.
.13e5	18		clc				clc 								; copy the address to temp0, adding 2 and updating.
.13e6	bd 03 01	lda $0103,x			lda 	$0103,x
.13e9	85 0c		sta $0c				sta 	temp0
.13eb	69 02		adc #$02			adc 	#2
.13ed	9d 03 01	sta $0103,x			sta 	$0103,x
.13f0	bd 04 01	lda $0104,x			lda 	$0104,x
.13f3	85 0d		sta $0d				sta 	temp0+1
.13f5	69 00		adc #$00			adc 	#0
.13f7	9d 04 01	sta $0104,x			sta 	$0104,x
.13fa	a0 01		ldy #$01			ldy 	#1 							; temp0 points to high byte of call, rts works that way
.13fc	b1 0c		lda ($0c),y			lda 	(temp0),y 					; so get the word there.
.13fe	aa		tax				tax
.13ff	c8		iny				iny
.1400	b1 0c		lda ($0c),y			lda 	(temp0),y
.1402	85 0d		sta $0d				sta 	temp0+1
.1404	86 0c		stx $0c				stx 	temp0
.1406	60		rts				rts
.1407					LoadIndirectTemp0:
.1407	a0 00		ldy #$00			ldy 	#0							; low byte into X
.1409	b1 0c		lda ($0c),y			lda 	(temp0),y
.140b	aa		tax				tax
.140c	c8		iny				iny
.140d	b1 0c		lda ($0c),y			lda 	(temp0),y 					; high byte into A
.140f	85 0d		sta $0d				sta 	temp0+1 					; copy out.
.1411	86 0c		stx $0c				stx 	temp0
.1413	60		rts				rts
.1414					EndMulDivContent:

;******  Return to file: runtime.asm


;******  Processing file: utility1.asm

>1414	2c 00					.word 	EndVariableClear-* 							; offset to next entry
>1416	63 6c 65 61 72 2e 76 61			.text 	"clear.variables:0",0 							; the text (must be lower case)
>141e	72 69 61 62 6c 65 73 3a 30 00
>1428						.align 	2								; force to even boundary.
.1428					VariableClear:
.1428	a9 00		lda #$00			lda 	#VarAddr & $FF
.142a	85 0c		sta $0c				sta 	temp0
.142c	a9 08		lda #$08			lda 	#VarAddr >> 8
.142e	85 0d		sta $0d				sta		temp0+1
.1430	a2 08		ldx #$08			ldx 	#VarPages
.1432	a0 00		ldy #$00			ldy 	#0
.1434	98		tya				tya
.1435	91 0c		sta ($0c),y	_VCLoop:sta 	(temp0),y
.1437	c8		iny				iny
.1438	d0 fb		bne $1435			bne 	_VCLoop
.143a	e6 0d		inc $0d				inc 	temp0+1
.143c	ca		dex				dex
.143d	d0 f6		bne $1435			bne 	_VCLoop
.143f	60		rts				rts
.1440					EndVariableClear:
>1440	15 00					.word 	EndHaltProgram-* 							; offset to next entry
>1442	68 61 6c 74 2e 70 72 6f			.text 	"halt.program:0",0 							; the text (must be lower case)
>144a	67 72 61 6d 3a 30 00
>1451						.align 	2								; force to even boundary.
.1452					HaltProgram:
.1452	4c 52 14	jmp $1452			jmp 	HaltProgram
.1455					EndHaltProgram:
>1455	16 00					.word 	EndBootAddress-* 							; offset to next entry
>1457	62 6f 6f 74 2e 61 64 64			.text 	"boot.address:0",0 							; the text (must be lower case)
>145f	72 65 73 73 3a 30 00
>1466						.align 	2								; force to even boundary.
.1466	a9 00		lda #$00			lda 	#BootAddr & $FF
.1468	a2 10		ldx #$10			ldx 	#BootAddr >> 8
.146a	60		rts				rts
.146b					EndBootAddress:
>146b	38 00					.word 	EndPrintHex-* 							; offset to next entry
>146d	70 72 69 6e 74 2e 68 65			.text 	"print.hex:1",0 							; the text (must be lower case)
>1475	78 3a 31 00
>1479						.align 	2								; force to even boundary.
.147a					PrintHex:
.147a	48		pha			pha
.147b	da		phx			phx
.147c	48		pha				pha
.147d	a9 20		lda #$20			lda 	#32
.147f	20 96 16	jsr $1696			jsr 	PrintCharacter
.1482	8a		txa				txa
.1483	20 8d 14	jsr $148d			jsr 	_PHex
.1486	68		pla				pla
.1487	20 8d 14	jsr $148d			jsr 	_PHex
.148a	fa		plx			plx
.148b	68		pla			pla
.148c	60		rts				rts
.148d	48		pha		_PHex:	pha
.148e	4a		lsr a				lsr 	a
.148f	4a		lsr a				lsr 	a
.1490	4a		lsr a				lsr 	a
.1491	4a		lsr a				lsr 	a
.1492	20 96 14	jsr $1496			jsr 	_PNibl
.1495	68		pla				pla
.1496	29 0f		and #$0f	_PNibl:	and 	#15
.1498	c9 0a		cmp #$0a			cmp 	#10
.149a	90 02		bcc $149e			bcc 	_PNoSkip
.149c	69 06		adc #$06			adc 	#6
.149e					_PNoSkip:
.149e	69 30		adc #$30			adc 	#48
.14a0	4c 96 16	jmp $1696			jmp 	PrintCharacter
.14a3					EndPrintHex:
>14a3	26 00					.word 	EndPrintString-* 							; offset to next entry
>14a5	70 72 69 6e 74 2e 73 74			.text 	"print.string:1",0 							; the text (must be lower case)
>14ad	72 69 6e 67 3a 31 00
>14b4						.align 	2								; force to even boundary.
.14b4					PrintString:
.14b4	48		pha			pha
.14b5	da		phx			phx
.14b6	85 0c		sta $0c				sta 	temp0
.14b8	86 0d		stx $0d				stx 	temp0+1
.14ba	a0 00		ldy #$00			ldy 	#0
.14bc	b1 0c		lda ($0c),y	_PSLoop:lda 	(temp0),y
.14be	f0 06		beq $14c6			beq 	_PSExit
.14c0	20 96 16	jsr $1696			jsr 	PrintCharacter
.14c3	c8		iny				iny
.14c4	d0 f6		bne $14bc			bne 	_PSLoop
.14c6					_PSExit:
.14c6	fa		plx			plx
.14c7	68		pla			pla
.14c8	60		rts				rts
.14c9					EndPrintString
>14c9	3f 00					.word 	EndPrintDecimal-* 							; offset to next entry
>14cb	70 72 69 6e 74 2e 69 6e			.text 	"print.int:1",0 							; the text (must be lower case)
>14d3	74 3a 31 00
>14d7						.align 	2								; force to even boundary.
.14d8					PrintDecimal:
.14d8	48		pha			pha
.14d9	da		phx			phx
.14da	48		pha				pha
.14db	a9 20		lda #$20			lda 	#32							; leading spaces.
.14dd	20 96 16	jsr $1696			jsr 	PrintCharacter
.14e0	68		pla				pla
.14e1	20 e7 14	jsr $14e7			jsr 	PDEntry
.14e4	fa		plx			plx
.14e5	68		pla			pla
.14e6	60		rts				rts
.14e7					PDEntry:
.14e7	85 0e		sta $0e				sta 	temp1						; save in temp1
.14e9	86 0f		stx $0f				stx 	temp1+1
.14eb					_PDRecurse:
.14eb	a9 0a		lda #$0a			lda 	#10 						; set base to 10.
.14ed	85 0c		sta $0c				sta 	temp0
.14ef	a9 00		lda #$00			lda 	#0
.14f1	85 0d		sta $0d				sta 	temp0+1
.14f3	20 ab 12	jsr $12ab			jsr 	Divide
.14f6	a5 08		lda $08				lda 	Reg16 						; push remainder on stack.
.14f8	48		pha				pha
.14f9	a5 0e		lda $0e				lda 	temp1						; call recursively if not zero
.14fb	05 0f		ora $0f				ora 	temp1+1
.14fd	f0 03		beq $1502			beq 	_PDNoRecurse
.14ff	20 eb 14	jsr $14eb			jsr 	_PDRecurse 					; recursively print
.1502					_PDNoRecurse:
.1502	68		pla				pla 								; restore and print
.1503	09 30		ora #$30			ora 	#48
.1505	4c 96 16	jmp $1696			jmp 	PrintCharacter
.1508					EndPrintDecimal:
>1508	2b 00					.word 	EndPrintSignedInt-* 							; offset to next entry
>150a	70 72 69 6e 74 2e 73 69			.text 	"print.sint:1",0 							; the text (must be lower case)
>1512	6e 74 3a 31 00
>1517						.align 	2								; force to even boundary.
.1518	e0 00		cpx #$00			cpx 	#0
.151a	f0 bc		beq $14d8			beq 	PrintDecimal
.151c	48		pha			pha
.151d	da		phx			phx
.151e	48		pha				pha
.151f	a9 20		lda #$20			lda 	#32
.1521	20 96 16	jsr $1696			jsr 	PrintCharacter
.1524	a9 2d		lda #$2d			lda 	#'-'
.1526	20 96 16	jsr $1696			jsr 	PrintCharacter
.1529	68		pla				pla
.152a	20 7a 15	jsr $157a			jsr 	Negate
.152d	20 e7 14	jsr $14e7			jsr 	PDEntry
.1530	fa		plx			plx
.1531	68		pla			pla
.1532	60		rts				rts
.1533					EndPrintSignedInt:

;******  Return to file: runtime.asm


;******  Processing file: utility2.asm

>1533	1c 00					.word 	EndMax-* 							; offset to next entry
>1535	6d 61 78 3a 32 00			.text 	"max:2",0 							; the text (must be lower case)
>153b						.align 	2								; force to even boundary.
.153c	a8		tay				tay 								; save in Y
.153d	cd 00 08	cmp $0800			cmp 	Param1 						; compare XA vs param1
.1540	8a		txa				txa
.1541	ed 01 08	sbc $0801			sbc 	Param1+1
.1544	98		tya				tya 								; ready to return original value.
.1545	90 01		bcc $1548			bcc 	MMReturnP1
.1547	60		rts				rts
.1548					MMReturnP1:
.1548	ad 00 08	lda $0800			lda 	Param1
.154b	ae 01 08	ldx $0801			ldx 	Param1+1
.154e	60		rts				rts
.154f					EndMax:
>154f	15 00					.word 	EndMin-* 							; offset to next entry
>1551	6d 69 6e 3a 32 00			.text 	"min:2",0 							; the text (must be lower case)
>1557						.align 	2								; force to even boundary.
.1558	a8		tay				tay 								; save in Y
.1559	cd 00 08	cmp $0800			cmp 	Param1 						; compare XA vs param1
.155c	8a		txa				txa
.155d	ed 01 08	sbc $0801			sbc 	Param1+1
.1560	98		tya				tya 								; ready to return original value.
.1561	b0 e5		bcs $1548			bcs 	MMReturnP1
.1563	60		rts				rts
.1564					EndMin:
>1564	0d 00					.word 	EndAbs-* 							; offset to next entry
>1566	61 62 73 3a 31 00			.text 	"abs:1",0 							; the text (must be lower case)
>156c						.align 	2								; force to even boundary.
.156c	e0 00		cpx #$00			cpx 	#0
.156e	30 0a		bmi $157a			bmi 	Negate
.1570	60		rts				rts
.1571					EndAbs:
>1571	18 00					.word 	EndNegate-* 							; offset to next entry
>1573	6e 65 67 3a 31 00			.text 	"neg:1",0 							; the text (must be lower case)
>1579						.align 	2								; force to even boundary.
.157a	48		pha		Negate:	pha
.157b	8a		txa				txa
.157c	49 ff		eor #$ff			eor 	#$FF
.157e	aa		tax				tax
.157f	68		pla				pla
.1580	49 ff		eor #$ff			eor 	#$FF
.1582	18		clc				clc
.1583	69 01		adc #$01			adc 	#1
.1585	90 01		bcc $1588			bcc 	_NGExit
.1587	e8		inx				inx
.1588	60		rts		_NGExit:rts
.1589					EndNegate:
>1589	1e 00					.word 	EndSgn-* 							; offset to next entry
>158b	73 67 6e 3a 31 00			.text 	"sgn:1",0 							; the text (must be lower case)
>1591						.align 	2								; force to even boundary.
.1592	a0 ff		ldy #$ff			ldy 	#$FF
.1594	e0 00		cpx #$00			cpx 	#0
.1596	30 07		bmi $159f			bmi 	_SGRetYA
.1598	d0 08		bne $15a2			bne 	_SGPositive
.159a	c8		iny				iny
.159b	c9 00		cmp #$00			cmp 	#0
.159d	d0 03		bne $15a2			bne 	_SGPositive
.159f					_SGRetYA:
.159f	98		tya				tya
.15a0	aa		tax				tax
.15a1	60		rts				rts
.15a2					_SGPositive:
.15a2	a9 01		lda #$01			lda 	#1
.15a4	a2 00		ldx #$00			ldx 	#0
.15a6	60		rts				rts
.15a7					EndSgn:
>15a7	17 00					.word 	EndLen-* 							; offset to next entry
>15a9	6c 65 6e 3a 31 00			.text 	"len:1",0 							; the text (must be lower case)
>15af						.align 	2								; force to even boundary.
.15b0	85 0c		sta $0c				sta 	temp0
.15b2	86 0d		stx $0d				stx 	temp0+1
.15b4	a0 ff		ldy #$ff			ldy 	#255
.15b6	c8		iny		_GetLen:iny
.15b7	b1 0c		lda ($0c),y			lda 	(temp0),y
.15b9	d0 fb		bne $15b6			bne 	_GetLen
.15bb	aa		tax				tax
.15bc	98		tya				tya
.15bd	60		rts				rts
.15be					EndLen:
>15be	26 00					.word 	EndAlloc-* 							; offset to next entry
>15c0	61 6c 6c 6f 63 3a 31 00			.text 	"alloc:1",0 							; the text (must be lower case)
>15c8						.align 	2								; force to even boundary.
.15c8	a8		tay				tay 								; XY is size.
.15c9	ad 1e 10	lda $101e			lda 	AllocMem 					; push allocated addr on stack
.15cc	48		pha				pha
.15cd	ad 1f 10	lda $101f			lda 	AllocMem+1
.15d0	48		pha				pha
.15d1	18		clc				clc 								; add XY to alloc mem
.15d2	98		tya				tya
.15d3	6d 1e 10	adc $101e			adc 	AllocMem
.15d6	8d 1e 10	sta $101e			sta 	AllocMem
.15d9	8a		txa				txa
.15da	6d 1f 10	adc $101f			adc 	AllocMem+1
.15dd	8d 1f 10	sta $101f			sta 	AllocMem+1
.15e0	68		pla				pla 								; restore and exit
.15e1	aa		tax				tax
.15e2	68		pla				pla
.15e3	60		rts				rts
.15e4					EndAlloc:
>15e4	35 00					.word 	EndRandom-* 							; offset to next entry
>15e6	72 61 6e 64 6f 6d 3a 30			.text 	"random:0",0 							; the text (must be lower case)
>15ee	00
>15ef						.align 	2								; force to even boundary.
.15f0	ad 06 08	lda $0806			lda 	RandomSeed 					; initialise if nonzero
.15f3	0d 07 08	ora $0807			ora 	RandomSeed+1
.15f6	d0 0a		bne $1602			bne 	_R16_NoInit
.15f8	a9 a3		lda #$a3			lda 	#$A3
.15fa	8d 06 08	sta $0806			sta 	RandomSeed
.15fd	a9 75		lda #$75			lda 	#$75
.15ff	8d 07 08	sta $0807			sta 	RandomSeed+1
.1602					_R16_NoInit:
.1602	4e 07 08	lsr $0807			lsr 	RandomSeed+1				; shift seed right
.1605	6e 06 08	ror $0806			ror 	RandomSeed
.1608	90 08		bcc $1612			bcc 	_R16_NoXor
.160a	ad 07 08	lda $0807			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.160d	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.160f	8d 07 08	sta $0807			sta 	RandomSeed+1
.1612					_R16_NoXor:
.1612	ad 06 08	lda $0806			lda 	RandomSeed					; copy result to evaluate stack.
.1615	ae 07 08	ldx $0807			ldx 	RandomSeed+1
.1618	60		rts				rts
.1619					EndRandom

;******  Return to file: runtime.asm


;******  Processing file: utility3.asm

>1619	16 00					.word 	EndPeekB-* 							; offset to next entry
>161b	70 65 65 6b 2e 62 3a 31			.text 	"peek.b:1",0 							; the text (must be lower case)
>1623	00
>1624						.align 	2								; force to even boundary.
.1624	85 0c		sta $0c				sta 	temp0
.1626	86 0d		stx $0d				stx 	temp0+1
.1628	a0 00		ldy #$00			ldy 	#0
.162a	b1 0c		lda ($0c),y			lda 	(temp0),y
.162c	a2 00		ldx #$00			ldx 	#0
.162e	60		rts				rts
.162f					EndPeekB:
>162f	18 00					.word 	EndPeekW-* 							; offset to next entry
>1631	70 65 65 6b 2e 77 3a 31			.text 	"peek.w:1",0 							; the text (must be lower case)
>1639	00
>163a						.align 	2								; force to even boundary.
.163a	85 0c		sta $0c				sta 	temp0
.163c	86 0d		stx $0d				stx 	temp0+1
.163e	a0 01		ldy #$01			ldy 	#1
.1640	b1 0c		lda ($0c),y			lda 	(temp0),y
.1642	aa		tax				tax
.1643	88		dey				dey
.1644	b1 0c		lda ($0c),y			lda 	(temp0),y
.1646	60		rts				rts
.1647					EndPeekW:
>1647	1a 00					.word 	EndPokeB-* 							; offset to next entry
>1649	70 6f 6b 65 2e 62 3a 32			.text 	"poke.b:2",0 							; the text (must be lower case)
>1651	00
>1652						.align 	2								; force to even boundary.
.1652	ac 00 08	ldy $0800			ldy 	Param1
.1655	84 0c		sty $0c				sty 	temp0
.1657	ac 01 08	ldy $0801			ldy 	Param1+1
.165a	84 0d		sty $0d				sty 	temp0+1
.165c	a0 00		ldy #$00			ldy 	#0
.165e	91 0c		sta ($0c),y			sta 	(temp0),y
.1660	60		rts				rts
.1661					EndPokeB:
>1661	20 00					.word 	EndPokeW-* 							; offset to next entry
>1663	70 6f 6b 65 2e 77 3a 32			.text 	"poke.w:2",0 							; the text (must be lower case)
>166b	00
>166c						.align 	2								; force to even boundary.
.166c	48		pha				pha
.166d	ac 00 08	ldy $0800			ldy 	Param1
.1670	84 0c		sty $0c				sty 	temp0
.1672	ac 01 08	ldy $0801			ldy 	Param1+1
.1675	84 0d		sty $0d				sty 	temp0+1
.1677	a0 00		ldy #$00			ldy 	#0
.1679	91 0c		sta ($0c),y			sta 	(temp0),y
.167b	c8		iny				iny
.167c	8a		txa				txa
.167d	91 0c		sta ($0c),y			sta 	(temp0),y
.167f	68		pla				pla
.1680	60		rts				rts
.1681					EndPokeW:

;******  Return to file: runtime.asm


;******  Processing file: sys/x16/porting.asm

=$9f20					Vera = $9F20
>1681	1d 00					.word 	EndPrintCharacter-* 							; offset to next entry
>1683	70 72 69 6e 74 2e 63 68			.text 	"print.character:1",0 							; the text (must be lower case)
>168b	61 72 61 63 74 65 72 3a 31 00
>1695						.align 	2								; force to even boundary.
.1696					PrintCharacter:
.1696	48		pha			pha
.1697	da		phx			phx
.1698	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.169b	fa		plx			plx
.169c	68		pla			pla
.169d	60		rts				rts
.169e					EndPrintCharacter:
>169e	18 00					.word 	EndPrintCRLF-* 							; offset to next entry
>16a0	70 72 69 6e 74 2e 63 72			.text 	"print.crlf:0",0 							; the text (must be lower case)
>16a8	6c 66 3a 30 00
>16ad						.align 	2								; force to even boundary.
.16ae	48		pha				pha
.16af	a9 0d		lda #$0d			lda 	#13
.16b1	20 96 16	jsr $1696			jsr 	PrintCharacter
.16b4	68		pla				pla
.16b5	60		rts				rts
.16b6					EndPrintCRLF:
>16b6	14 00					.word 	EndReadTimer-* 							; offset to next entry
>16b8	72 65 61 64 2e 74 69 6d			.text 	"read.timer:0",0 							; the text (must be lower case)
>16c0	65 72 3a 30 00
>16c5						.align 	2								; force to even boundary.
.16c6					ReadTimer:
.16c6	20 de ff	jsr $ffde			jsr 	$FFDE						; the documentation is mostly wrong it's YXA.
.16c9	60		rts				rts
.16ca					EndReadTimer:
>16ca	15 00					.word 	EndExitEmulator-* 							; offset to next entry
>16cc	65 78 69 74 2e 65 6d 75			.text 	"exit.emulator:0",0 							; the text (must be lower case)
>16d4	6c 61 74 6f 72 3a 30 00
>16dc						.align 	2								; force to even boundary.
.16dc	4c ff ff	jmp $ffff			jmp 	$FFFF
.16df					EndExitEmulator:
>16df	25 00					.word 	EndVPoke-* 							; offset to next entry
>16e1	70 6f 6b 65 2e 76 3a 33			.text 	"poke.v:3",0 							; the text (must be lower case)
>16e9	00
>16ea						.align 	2								; force to even boundary.
.16ea	a8		tay				tay 								; save byte in Y
.16eb	ad 00 08	lda $0800			lda 	Param1 						; set Vera address
.16ee	09 10		ora #$10			ora 	#$10 						; set 1 increment
.16f0	8d 22 9f	sta $9f22			sta 	Vera+2
.16f3	ad 03 08	lda $0803			lda 	Param2+1
.16f6	8d 21 9f	sta $9f21			sta 	Vera+1
.16f9	ad 02 08	lda $0802			lda 	Param2
.16fc	8d 20 9f	sta $9f20			sta 	Vera
.16ff	8c 23 9f	sty $9f23			sty 	Vera+3
.1702	98		tya				tya
.1703	60		rts				rts
.1704					EndVPoke:
>1704	29 00					.word 	EndVWPoke-* 							; offset to next entry
>1706	70 6f 6b 65 2e 76 77 3a			.text 	"poke.vw:3",0 							; the text (must be lower case)
>170e	33 00
>1710						.align 	2								; force to even boundary.
.1710	a8		tay				tay 								; save byte in Y
.1711	ad 00 08	lda $0800			lda 	Param1 						; set Vera address
.1714	09 10		ora #$10			ora 	#$10 						; set 1 increment
.1716	8d 22 9f	sta $9f22			sta 	Vera+2
.1719	ad 03 08	lda $0803			lda 	Param2+1
.171c	8d 21 9f	sta $9f21			sta 	Vera+1
.171f	ad 02 08	lda $0802			lda 	Param2
.1722	8d 20 9f	sta $9f20			sta 	Vera
.1725	8c 23 9f	sty $9f23			sty 	Vera+3 						; write out a word.
.1728	8e 23 9f	stx $9f23			stx 	Vera+3
.172b	98		tya				tya
.172c	60		rts				rts
.172d					EndVWPoke:
>172d	1d 00					.word 	EndVPeek-* 							; offset to next entry
>172f	70 65 65 6b 2e 76 3a 32			.text 	"peek.v:2",0 							; the text (must be lower case)
>1737	00
>1738						.align 	2								; force to even boundary.
.1738	8e 21 9f	stx $9f21			stx 	Vera+1
.173b	8d 20 9f	sta $9f20			sta 	Vera
.173e	ad 00 08	lda $0800			lda 	Param1
.1741	8d 22 9f	sta $9f22			sta 	Vera+2
.1744	ad 23 9f	lda $9f23			lda 	Vera+3
.1747	a2 00		ldx #$00			ldx 	#0
.1749	60		rts				rts
.174a					EndVPeek:

;******  Return to file: runtime.asm

.174a					RuntimeEnd:

;******  End of listing
