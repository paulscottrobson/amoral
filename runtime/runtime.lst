
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -q --m6502 -o runtime.prg -L runtime.lst runtime.asm
; Sun Nov 15 17:03:45 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: runtime.asm


;******  Processing file: macros.asm


;******  Return to file: runtime.asm

=$1000					BootAddr = $1000 							; Runtime loads at this address (e.g. Boot)
=$800					VarAddr = $800 								; Variable memory here (128 per 1/4k) PAGE BOUNDARY.
=8					VarPages = 8 								; Number of pages of variables (256 byte pages)
=$08					ZeroAddr = $08 								; Zero page goes here.
=0					test = 0									; test to run (default is build final)
=$08					Reg16 = ZeroAddr 							; the current value register.
=10					Pctr = ZeroAddr+2 							; the program counter (e.g. the next instruction)
=12					temp0 = ZeroAddr+4 							; temporary registers
=14					temp1 = ZeroAddr+6
=16					ZeroAddrEnd = ZeroAddr+8 					; marks end of allocated space.
.1000	4c 00 10	jmp $1000			jmp 	BootAddr 					; test=0 what we normally get, no start address.
>1016	08						.byte 	ZeroAddr 					; Low byte of ZeroPage used.
>1017	10						.byte 	ZeroAddrEnd 				; High byte of ZeroPage used.
>1018	00 10						.word 	BootAddr 					; the address of boot
>101a	00 08						.word 	VarAddr 					; the address of the variables
>101c	a7 14						.word	RunTimeEnd 					; where the runtime ends (e.g. where code goes)
>101e	00 00						.word 	$0000 						; address of allocatable memory (set up by compiler)
>1020	9b 02					.word 	EndRunPCode-* 							; offset to next entry
>1022	72 75 6e 2e 70 63 6f 64			.text 	"run.pcode:0",0 							; the text (must be lower case)
>102a	65 3a 30 00
>102e						.align 	2								; force to even boundary.

;******  Processing file: interpreter.asm

.102e					RunPCode:
.102e	86 09		stx $09				stx 	Reg16+1 					; save the current XA values.
.1030	85 08		sta $08				sta 	Reg16
.1032	68		pla				pla 								; pull the address into the PC
.1033	85 0a		sta $0a				sta 	Pctr
.1035	68		pla				pla
.1036	85 0b		sta $0b				sta 	Pctr+1
.1038	e6 0a		inc $0a			inc 	Pctr
.103a	d0 02		bne $103e		bne 	nocarry
.103c	e6 0b		inc $0b			inc 	1+(Pctr)
.103e					nocarry:
.103e					ExecLoop:
.103e	a0 00		ldy #$00			ldy 	#0							; get the next instruction
.1040	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1042	e6 0a		inc $0a			inc 	Pctr
.1044	d0 02		bne $1048		bne 	nocarry
.1046	e6 0b		inc $0b			inc 	1+(Pctr)
.1048					nocarry:
.1048	0a		asl a				asl 	a 							; shift bit 7 into carry.
.1049	b0 30		bcs $107b			bcs 	CommandHandler 				; 80-FF it's a command
.104b	85 0c		sta $0c				sta 	temp0 						; construct the call address in temp0
.104d	b1 0a		lda ($0a),y			lda 	(PCtr),y 					; get the MSB
.104f	85 0d		sta $0d				sta 	temp0+1
.1051	e6 0a		inc $0a			inc 	Pctr
.1053	d0 02		bne $1057		bne 	nocarry
.1055	e6 0b		inc $0b			inc 	1+(Pctr)
.1057					nocarry:
.1057	a5 0a		lda $0a				lda 	Pctr 						; save PCTR on 6502 stack
.1059	48		pha				pha
.105a	a5 0b		lda $0b				lda 	Pctr+1
.105c	48		pha				pha
.105d	a5 08		lda $08				lda 	Reg16 						; restore Reg16 into XA
.105f	a6 09		ldx $09				ldx 	Reg16+1
.1061	20 71 10	jsr $1071			jsr 	CallTemp0 					; call the routine as 6502 code.
.1064	86 09		stx $09				stx 	Reg16+1 					; save Reg16 back
.1066	85 08		sta $08				sta 	Reg16
.1068	68		pla				pla 								; restore the program counter
.1069	85 0b		sta $0b				sta 	Pctr+1
.106b	68		pla				pla
.106c	85 0a		sta $0a				sta 	Pctr
.106e	4c 3e 10	jmp $103e			jmp 	ExecLoop 					; and go round again.
.1071					CallTemp0:
.1071	6c 0c 00	jmp ($000c)			jmp 	(temp0)
.1074					Command_Return:
.1074	a5 08		lda $08				lda 	Reg16 						; get XA back
.1076	a6 09		ldx $09				ldx 	Reg16+1
.1078	6c 0a 00	jmp ($000a)			jmp 	(Pctr)						; and go back to the caller.
.107b					CommandHandler:
.107b	6a		ror a				ror 	a 							; patch it back so it has the full opcode.
.107c	a8		tay				tay  								; save it in Y for use by the commands.
.107d	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a unary operation.
.107f	b0 05		bcs $1086			bcs 	_CHIsUnary
.1081	29 0f		and #$0f			and 	#$0F 						; get the command number out.
.1083	4c 8a 10	jmp $108a			jmp 	_CHCall 					; go do the call
.1086					_CHIsUnary:
.1086	29 0f		and #$0f			and 	#$0F 						; this is the unary command number
.1088	09 10		ora #$10			ora 	#$10 						; mapped onto $10-$1F
.108a					_CHCall:
.108a	0a		asl a				asl 	a 							; now offset in the jump table and into X
.108b	aa		tax				tax
.108c	bd 9c 10	lda $109c,x			lda 	JumpTable,x 				; copy the jump table vectors into temp0
.108f	85 0c		sta $0c				sta 	temp0
.1091	bd 9d 10	lda $109d,x			lda 	JumpTable+1,x
.1094	85 0d		sta $0d				sta 	temp0+1
.1096	6c 0c 00	jmp ($000c)			jmp 	(temp0)						; and go there to execute with the opcode in Y.
.1099					OpcodeError:
.1099	a2 ee		ldx #$ee			ldx 	#$EE 						; EE = Error :)
>109b	db					.byte 	$DB
.109c					JumpTable:

;******  Processing file: generated/jumptable.inc

>109c	dc 10					.word LoadHandler              ; $80 LDR
>109e	21 11					.word Andhandler               ; $81 AND
>10a0	33 11					.word Orhandler                ; $82 ORR
>10a2	45 11					.word Xorhandler               ; $83 XOR
>10a4	fb 10					.word Addhandler               ; $84 ADD
>10a6	0e 11					.word Subhandler               ; $85 SUB
>10a8	36 12					.word MultiplyHandler          ; $86 MLT
>10aa	6b 12					.word DivideHandler            ; $87 DIV
>10ac	84 12					.word ModulusHandler           ; $88 MOD
>10ae	99 10					.word OpcodeError              ; $89 ?
>10b0	ea 10					.word StoreHandler             ; $8a STR
>10b2	d4 11					.word Branch_Always            ; $8b BRA
>10b4	e3 11					.word Branch_Zero              ; $8c BEQ
>10b6	eb 11					.word Branch_NonZero           ; $8d BNE
>10b8	ff 11					.word Branch_Minus             ; $8e BMI
>10ba	05 12					.word Branch_Positive          ; $8f BPL
>10bc	0b 12					.word Inc_Unary                ; $f0 INC
>10be	14 12					.word Dec_Unary                ; $f1 DEC
>10c0	1f 12					.word Shl_Unary                ; $f2 SHL
>10c2	26 12					.word Shr_Unary                ; $f3 SHR
>10c4	2d 12					.word Clr_Unary                ; $f4 CLR
>10c6	74 10					.word Command_Return           ; $f5 RET
>10c8	99 10					.word OpcodeError              ; $f6 ?
>10ca	99 10					.word OpcodeError              ; $f7 ?
>10cc	99 10					.word OpcodeError              ; $f8 ?
>10ce	99 10					.word OpcodeError              ; $f9 ?
>10d0	99 10					.word OpcodeError              ; $fa ?
>10d2	99 10					.word OpcodeError              ; $fb ?
>10d4	99 10					.word OpcodeError              ; $fc ?
>10d6	99 10					.word OpcodeError              ; $fd ?
>10d8	99 10					.word OpcodeError              ; $fe ?
>10da	99 10					.word OpcodeError              ; $ff ?

;******  Return to file: interpreter.asm


;******  Return to file: runtime.asm


;******  Processing file: commands.asm

.10dc					LoadHandler:
.10dc	20 57 11	jsr $1157			jsr 	EvaluateValue 				; temp0 = target value.
.10df	a5 0c		lda $0c				lda 	temp0						; copy value into register
.10e1	85 08		sta $08				sta 	Reg16
.10e3	a5 0d		lda $0d				lda 	temp0+1
.10e5	85 09		sta $09				sta 	Reg16+1
.10e7	4c 3e 10	jmp $103e			jmp 	ExecLoop
.10ea					StoreHandler:
.10ea	20 8c 11	jsr $118c			jsr 	EvaluateAddress 			; temp0 = target address.
.10ed	a0 00		ldy #$00			ldy 	#0							; write register out
.10ef	a5 08		lda $08				lda 	Reg16
.10f1	91 0c		sta ($0c),y			sta 	(temp0),y
.10f3	a5 09		lda $09				lda 	Reg16+1
.10f5	c8		iny				iny
.10f6	91 0c		sta ($0c),y			sta 	(temp0),y
.10f8	4c 3e 10	jmp $103e			jmp 	ExecLoop
.10fb					Addhandler:
.10fb	20 57 11	jsr $1157			jsr 	EvaluateValue
.10fe	18		clc				clc
.10ff	a5 08		lda $08				lda 	Reg16
.1101	65 0c		adc $0c				adc 	temp0
.1103	85 08		sta $08				sta 	Reg16
.1105	a5 09		lda $09				lda 	Reg16+1
.1107	65 0d		adc $0d				adc 	temp0+1
.1109	85 09		sta $09				sta 	Reg16+1
.110b	4c 3e 10	jmp $103e			jmp 	ExecLoop
.110e					Subhandler:
.110e	20 57 11	jsr $1157			jsr 	EvaluateValue
.1111	38		sec				sec
.1112	a5 08		lda $08				lda 	Reg16
.1114	e5 0c		sbc $0c				sbc 	temp0
.1116	85 08		sta $08				sta 	Reg16
.1118	a5 09		lda $09				lda 	Reg16+1
.111a	e5 0d		sbc $0d				sbc 	temp0+1
.111c	85 09		sta $09				sta 	Reg16+1
.111e	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1121					Andhandler:
.1121	20 57 11	jsr $1157			jsr 	EvaluateValue
.1124	a5 08		lda $08				lda 	Reg16
.1126	25 0c		and $0c				and 	temp0
.1128	85 08		sta $08				sta 	Reg16
.112a	a5 09		lda $09				lda 	Reg16+1
.112c	25 0d		and $0d				and 	temp0+1
.112e	85 09		sta $09				sta 	Reg16+1
.1130	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1133					Orhandler:
.1133	20 57 11	jsr $1157			jsr 	EvaluateValue
.1136	a5 08		lda $08				lda 	Reg16
.1138	05 0c		ora $0c				ora 	temp0
.113a	85 08		sta $08				sta 	Reg16
.113c	a5 09		lda $09				lda 	Reg16+1
.113e	05 0d		ora $0d				ora 	temp0+1
.1140	85 09		sta $09				sta 	Reg16+1
.1142	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1145					Xorhandler:
.1145	20 57 11	jsr $1157			jsr 	EvaluateValue
.1148	a5 08		lda $08				lda 	Reg16
.114a	45 0c		eor $0c				eor 	temp0
.114c	85 08		sta $08				sta 	Reg16
.114e	a5 09		lda $09				lda 	Reg16+1
.1150	45 0d		eor $0d				eor 	temp0+1
.1152	85 09		sta $09				sta 	Reg16+1
.1154	4c 3e 10	jmp $103e			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: support.asm

.1157					EvaluateValue:
.1157	98		tya				tya 								; get EAC part and save in X
.1158	29 70		and #$70			and 	#$70
.115a	aa		tax				tax
.115b	c9 20		cmp #$20			cmp 	#$20 						; check if 00,01 if so it is variable or absolute
.115d	b0 1d		bcs $117c			bcs 	_EDMemory
.115f	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1161	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1163	85 0c		sta $0c				sta 	temp0
.1165	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1167	e6 0a		inc $0a			inc 	Pctr
.1169	d0 02		bne $116d		bne 	nocarry
.116b	e6 0b		inc $0b			inc 	1+(Pctr)
.116d					nocarry:
.116d	e0 00		cpx #$00			cpx 	#0 							; if it is 000 then it is a one byte
.116f	f0 0a		beq $117b			beq 	_EACalcValue
.1171	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.1173	85 0d		sta $0d				sta 	temp0+1
.1175	e6 0a		inc $0a			inc 	Pctr
.1177	d0 02		bne $117b		bne 	nocarry
.1179	e6 0b		inc $0b			inc 	1+(Pctr)
.117b					nocarry:
.117b					_EACalcValue:
.117b	60		rts				rts
.117c					_EDMemory:
.117c	20 8c 11	jsr $118c			jsr	 	EvaluateAddress 			; evaluate the address.
.117f	a0 00		ldy #$00			ldy 	#0 							; 16 bit load indirect (temp0) => temp0
.1181	b1 0c		lda ($0c),y			lda 	(temp0),y
.1183	aa		tax				tax
.1184	c8		iny				iny
.1185	b1 0c		lda ($0c),y			lda 	(temp0),y
.1187	86 0c		stx $0c				stx 	temp0
.1189	85 0d		sta $0d				sta 	temp0+1
.118b	60		rts				rts
.118c					EvaluateAddress:
.118c	98		tya				tya 								; get EAC part of opcode.
.118d	29 70		and #$70			and 	#$70
.118f	c9 40		cmp #$40			cmp 	#$40 						; is it an absolute address
.1191	f0 29		beq $11bc			beq 	_EAAbsolute
.1193	aa		tax				tax 								; save in X
.1194	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1196	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1198	85 0c		sta $0c				sta 	temp0
.119a	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.119c	e6 0a		inc $0a			inc 	Pctr
.119e	d0 02		bne $11a2		bne 	nocarry
.11a0	e6 0b		inc $0b			inc 	1+(Pctr)
.11a2					nocarry:
.11a2	e0 20		cpx #$20			cpx 	#$20 						; if it is 010 then it is a one byte
.11a4	f0 0a		beq $11b0			beq 	_EACalcVarAddress
.11a6	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.11a8	85 0d		sta $0d				sta 	temp0+1
.11aa	e6 0a		inc $0a			inc 	Pctr
.11ac	d0 02		bne $11b0		bne 	nocarry
.11ae	e6 0b		inc $0b			inc 	1+(Pctr)
.11b0					nocarry:
.11b0					_EACalcVarAddress:
.11b0	06 0c		asl $0c				asl 	temp0 						; double the variable number
.11b2	26 0d		rol $0d				rol 	temp0+1
.11b4	18		clc				clc 								; add the page address of variable data on.
.11b5	a5 0d		lda $0d				lda 	temp0+1
.11b7	69 08		adc #$08			adc 	#VarAddr/256
.11b9	85 0d		sta $0d				sta 	temp0+1
.11bb	60		rts				rts
.11bc					_EAAbsolute:
.11bc	a0 00		ldy #$00			ldy 	#0 							; get the address into temp0
.11be	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11c0	85 0c		sta $0c				sta 	temp0
.11c2	c8		iny				iny
.11c3	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11c5	85 0d		sta $0d				sta 	temp0+1
.11c7					ReturnBump2
.11c7	e6 0a		inc $0a			inc 	Pctr
.11c9	d0 02		bne $11cd		bne 	nocarry
.11cb	e6 0b		inc $0b			inc 	1+(Pctr)
.11cd					nocarry:
.11cd					ReturnBump1:
.11cd	e6 0a		inc $0a			inc 	Pctr
.11cf	d0 02		bne $11d3		bne 	nocarry
.11d1	e6 0b		inc $0b			inc 	1+(Pctr)
.11d3					nocarry:
.11d3	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: branches.asm

.11d4					Branch_Always:
.11d4	a0 00		ldy #$00			ldy 	#0
.11d6	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11d8	aa		tax				tax
.11d9	c8		iny				iny
.11da	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11dc	85 0b		sta $0b				sta 	Pctr+1
.11de	86 0a		stx $0a				stx 	Pctr
.11e0	4c 3e 10	jmp $103e			jmp 	ExecLoop
.11e3					Branch_Zero:
.11e3	a5 08		lda $08				lda 	Reg16
.11e5	05 09		ora $09				ora 	Reg16+1
.11e7	f0 eb		beq $11d4			beq 	Branch_Always
.11e9	d0 06		bne $11f1			bne 	Branch_Fail
.11eb					Branch_NonZero:
.11eb	a5 08		lda $08				lda 	Reg16
.11ed	05 09		ora $09				ora 	Reg16+1
.11ef	d0 e3		bne $11d4			bne 	Branch_Always
.11f1					Branch_Fail:
.11f1	18		clc				clc
.11f2	a5 0a		lda $0a				lda 	Pctr
.11f4	69 02		adc #$02			adc 	#2
.11f6	85 0a		sta $0a				sta 	Pctr
.11f8	d0 02		bne $11fc			bne 	_BFNoCarry
.11fa	e6 0b		inc $0b				inc 	Pctr+1
.11fc					_BFNoCarry:
.11fc	4c 3e 10	jmp $103e			jmp 	ExecLoop
.11ff					Branch_Minus:
.11ff	a5 09		lda $09				lda 	Reg16+1
.1201	30 d1		bmi $11d4			bmi 	Branch_Always
.1203	10 ec		bpl $11f1			bpl 	Branch_Fail
.1205					Branch_Positive:
.1205	a5 09		lda $09				lda 	Reg16+1
.1207	10 cb		bpl $11d4			bpl 	Branch_Always
.1209	30 e6		bmi $11f1			bmi 	Branch_Fail

;******  Return to file: runtime.asm


;******  Processing file: unary.asm

.120b					Inc_Unary:
.120b	e6 08		inc $08			inc 	Reg16
.120d	d0 02		bne $1211		bne 	nocarry
.120f	e6 09		inc $09			inc 	1+(Reg16)
.1211					nocarry:
.1211	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1214					Dec_Unary:
.1214	a5 08		lda $08			lda 	Reg16
.1216	d0 02		bne $121a		bne 	noborrow
.1218	c6 09		dec $09			dec 	1+(Reg16)
.121a					noborrow:
.121a	c6 08		dec $08			dec 	Reg16
.121c	4c 3e 10	jmp $103e			jmp 	ExecLoop
.121f					Shl_Unary:
.121f	06 08		asl $08				asl 	Reg16
.1221	26 09		rol $09				rol 	Reg16+1
.1223	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1226					Shr_Unary:
.1226	46 09		lsr $09				lsr 	Reg16+1
.1228	66 08		ror $08				ror 	Reg16
.122a	4c 3e 10	jmp $103e			jmp 	ExecLoop
.122d					Clr_Unary:
.122d	a9 00		lda #$00			lda 	#0
.122f	85 08		sta $08				sta		Reg16
.1231	85 09		sta $09				sta 	Reg16+1
.1233	4c 3e 10	jmp $103e			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: multiply.asm

.1236					MultiplyHandler:
.1236	20 57 11	jsr $1157			jsr 	EvaluateValue 				; temp0 = target value.
.1239	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.123b	85 0e		sta $0e				sta 	temp1
.123d	a5 09		lda $09				lda	 	Reg16+1
.123f	85 0f		sta $0f				sta 	temp1+1
.1241	20 47 12	jsr $1247			jsr 	Multiply 					; Reg16 := temp0 * temp1
.1244	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1247					Multiply:
.1247	a9 00		lda #$00			lda 	#0 							; zero total.
.1249	85 08		sta $08				sta 	Reg16
.124b	85 09		sta $09				sta 	Reg16+1
.124d					_MultLoop:
.124d	46 0d		lsr $0d				lsr 	temp0+1
.124f	66 0c		ror $0c				ror 	temp0
.1251	90 0d		bcc $1260			bcc 	_MultNoAdd
.1253	18		clc				clc
.1254	a5 0e		lda $0e				lda 	temp1
.1256	65 08		adc $08				adc 	Reg16
.1258	85 08		sta $08				sta 	Reg16
.125a	a5 0f		lda $0f				lda 	temp1+1
.125c	65 09		adc $09				adc 	Reg16+1
.125e	85 09		sta $09				sta 	Reg16+1
.1260					_MultNoAdd:
.1260	06 0e		asl $0e				asl 	temp1
.1262	26 0f		rol $0f				rol 	temp1+1
.1264	a5 0c		lda $0c				lda 	temp0
.1266	05 0d		ora $0d				ora 	temp0+1
.1268	d0 e3		bne $124d			bne 	_MultLoop
.126a	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: divide.asm

.126b					DivideHandler:
.126b	20 57 11	jsr $1157			jsr 	EvaluateValue 				; temp0 = target value.
.126e	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.1270	85 0e		sta $0e				sta 	temp1
.1272	a5 09		lda $09				lda	 	Reg16+1
.1274	85 0f		sta $0f				sta 	temp1+1
.1276	20 95 12	jsr $1295			jsr 	Divide 						; temp1 := temp1 / temp0
.1279	a5 0e		lda $0e				lda 	temp1 						; copy result into register
.127b	85 08		sta $08				sta 	Reg16
.127d	a5 0f		lda $0f				lda 	temp1+1
.127f	85 09		sta $09				sta 	Reg16+1
.1281	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1284					ModulusHandler:
.1284	20 57 11	jsr $1157			jsr 	EvaluateValue 				; temp0 = target value.
.1287	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.1289	85 0e		sta $0e				sta 	temp1
.128b	a5 09		lda $09				lda	 	Reg16+1
.128d	85 0f		sta $0f				sta 	temp1+1
.128f	20 95 12	jsr $1295			jsr 	Divide 						; temp1 := temp1 / temp0, mod => Reg16
.1292	4c 3e 10	jmp $103e			jmp 	ExecLoop
.1295					Divide:
.1295	a9 00		lda #$00			lda 	#0 							; set A = 0
.1297	85 08		sta $08				sta 	Reg16
.1299	85 09		sta $09				sta 	Reg16+1
.129b	a0 10		ldy #$10			ldy 	#16 						; loop round 16 times.
.129d					_DivLoop:
.129d	06 0e		asl $0e				asl 	temp1 						; shift QA left. Q first
.129f	26 0f		rol $0f				rol 	temp1+1
.12a1	26 08		rol $08				rol 	Reg16 						; shift A left carrying in.
.12a3	26 09		rol $09				rol 	Reg16+1
.12a5	38		sec				sec 								; calculate A-M, result in XA/C
.12a6	a5 08		lda $08				lda 	Reg16
.12a8	e5 0c		sbc $0c				sbc 	temp0
.12aa	aa		tax				tax
.12ab	a5 09		lda $09				lda 	Reg16+1
.12ad	e5 0d		sbc $0d				sbc 	temp0+1
.12af	90 06		bcc $12b7			bcc 	_DivNoUpdate 				; if A >= M then store result and set Q bit 0.
.12b1	85 09		sta $09				sta 	Reg16+1
.12b3	86 08		stx $08				stx 	Reg16
.12b5	e6 0e		inc $0e				inc 	temp1 						; we know it is even.
.12b7					_DivNoUpdate:
.12b7	88		dey				dey
.12b8	d0 e3		bne $129d			bne 	_DivLoop
.12ba	60		rts				rts

;******  Return to file: runtime.asm

.12bb					EndRunPCode:

;******  Processing file: muldiv.asm

>12bb	40 00					.word 	EndStringConstant-* 							; offset to next entry
>12bd	73 74 72 69 6e 67 2e 63			.text 	"string.constant:0",0 							; the text (must be lower case)
>12c5	6f 6e 73 74 61 6e 74 3a 30 00
>12cf						.align 	2								; force to even boundary.
.12d0					StringConstant:
.12d0	68		pla				pla 										; pull address and save in temp0
.12d1	85 0c		sta $0c				sta 	temp0
.12d3	68		pla				pla
.12d4	85 0d		sta $0d				sta 	temp0+1
.12d6	e6 0c		inc $0c			inc 	temp0
.12d8	d0 02		bne $12dc		bne 	nocarry
.12da	e6 0d		inc $0d			inc 	1+(temp0)
.12dc					nocarry:
.12dc	a0 00		ldy #$00			ldy 	#0 									; figure out the end of the string.
.12de	b1 0c		lda ($0c),y	_SCEnd:	lda 	(temp0),y
.12e0	c8		iny				iny
.12e1	c9 00		cmp #$00			cmp 	#0
.12e3	d0 f9		bne $12de			bne 	_SCEnd
.12e5	18		clc				clc 										; add Y to temp0, to continue, while putting
.12e6	84 0e		sty $0e				sty 	temp1 								; original value into XY
.12e8	18		clc				clc
.12e9	a5 0c		lda $0c				lda 	temp0
.12eb	a8		tay				tay
.12ec	65 0e		adc $0e				adc 	temp1
.12ee	85 0c		sta $0c				sta 	temp0
.12f0	a5 0d		lda $0d				lda 	temp0+1
.12f2	aa		tax				tax
.12f3	69 00		adc #$00			adc 	#0
.12f5	85 0d		sta $0d				sta 	temp0+1
.12f7	98		tya				tya 										; value now in XA
.12f8	6c 0c 00	jmp ($000c)			jmp 	(temp0)								; and continue.
.12fb					EndStringConstant:
>12fb	22 00					.word 	EndMultiplyImmediate-* 							; offset to next entry
>12fd	6d 75 6c 74 69 70 6c 79			.text 	"multiply.immediate:0",0 							; the text (must be lower case)
>1305	2e 69 6d 6d 65 64 69 61 74 65 3a 30 00
>1312						.align 	2								; force to even boundary.
.1312					MultiplyImmediate:
.1312	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.1315	20 47 12	jsr $1247			jsr 	Multiply
.1318	a5 08		lda $08				lda 	Reg16
.131a	a6 09		ldx $09				ldx 	Reg16+1
.131c	60		rts				rts
.131d					EndMultiplyImmediate:
>131d	25 00					.word 	EndMultiplyAbsolute-* 							; offset to next entry
>131f	6d 75 6c 74 69 70 6c 79			.text 	"multiply.absolute:0",0 							; the text (must be lower case)
>1327	2e 61 62 73 6f 6c 75 74 65 3a 30 00
>1333						.align 	2								; force to even boundary.
.1334					MultiplyAbsolute:
.1334	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.1337	20 f1 13	jsr $13f1			jsr 	LoadIndirectTemp0
.133a	20 47 12	jsr $1247			jsr 	Multiply
.133d	a5 08		lda $08				lda 	Reg16
.133f	a6 09		ldx $09				ldx 	Reg16+1
.1341	60		rts				rts
.1342					EndMultiplyAbsolute:
>1342	21 00					.word 	EndDivideImmediate-* 							; offset to next entry
>1344	64 69 76 69 64 65 2e 69			.text 	"divide.immediate:0",0 							; the text (must be lower case)
>134c	6d 6d 65 64 69 61 74 65 3a 30 00
>1357						.align 	2								; force to even boundary.
.1358					DivideImmediate:
.1358	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.135b	20 95 12	jsr $1295			jsr 	Divide
.135e	a5 0e		lda $0e				lda 	temp1
.1360	a6 0f		ldx $0f				ldx 	temp1+1
.1362	60		rts				rts
.1363					EndDivideImmediate:
>1363	23 00					.word 	EndDivideAbsolute-* 							; offset to next entry
>1365	64 69 76 69 64 65 2e 61			.text 	"divide.absolute:0",0 							; the text (must be lower case)
>136d	62 73 6f 6c 75 74 65 3a 30 00
>1377						.align 	2								; force to even boundary.
.1378					DivideAbsolute:
.1378	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.137b	20 f1 13	jsr $13f1			jsr 	LoadIndirectTemp0
.137e	20 95 12	jsr $1295			jsr 	Divide
.1381	a5 0e		lda $0e				lda 	temp1
.1383	a6 0f		ldx $0f				ldx 	temp1+1
.1385	60		rts				rts
.1386					EndDivideAbsolute:
>1386	21 00					.word 	EndModulusImmediate-* 							; offset to next entry
>1388	6d 6f 64 75 6c 75 73 2e			.text 	"modulus.immediate:0",0 							; the text (must be lower case)
>1390	69 6d 6d 65 64 69 61 74 65 3a 30 00
>139c						.align 	2								; force to even boundary.
.139c					ModulusImmediate:
.139c	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.139f	20 95 12	jsr $1295			jsr 	Divide
.13a2	a5 08		lda $08				lda 	Reg16
.13a4	a6 09		ldx $09				ldx 	Reg16+1
.13a6	60		rts				rts
.13a7					EndModulusImmediate:
>13a7	57 00					.word 	EndMulDivContent-* 							; offset to next entry
>13a9	6d 6f 64 75 6c 75 73 2e			.text 	"modulus.absolute:0",0 							; the text (must be lower case)
>13b1	61 62 73 6f 6c 75 74 65 3a 30 00
>13bc						.align 	2								; force to even boundary.
.13bc					ModulusAbsolute:
.13bc	20 ca 13	jsr $13ca			jsr 	SaveXTemp1GetTemp0
.13bf	20 f1 13	jsr $13f1			jsr 	LoadIndirectTemp0
.13c2	20 95 12	jsr $1295			jsr 	Divide
.13c5	a5 08		lda $08				lda 	Reg16
.13c7	a6 09		ldx $09				ldx 	Reg16+1
.13c9	60		rts				rts
.13ca					SaveXTemp1GetTemp0:
.13ca	85 0e		sta $0e				sta 	temp1 						; write XA out.
.13cc	86 0f		stx $0f				stx 	temp1+1
.13ce	ba		tsx				tsx 								; get stack pointer so we can access return two up.
.13cf	18		clc				clc 								; copy the address to temp0, adding 2 and updating.
.13d0	bd 03 01	lda $0103,x			lda 	$0103,x
.13d3	85 0c		sta $0c				sta 	temp0
.13d5	69 02		adc #$02			adc 	#2
.13d7	9d 03 01	sta $0103,x			sta 	$0103,x
.13da	bd 04 01	lda $0104,x			lda 	$0104,x
.13dd	85 0d		sta $0d				sta 	temp0+1
.13df	69 00		adc #$00			adc 	#0
.13e1	9d 04 01	sta $0104,x			sta 	$0104,x
.13e4	a0 01		ldy #$01			ldy 	#1 							; temp0 points to high byte of call, rts works that way
.13e6	b1 0c		lda ($0c),y			lda 	(temp0),y 					; so get the word there.
.13e8	aa		tax				tax
.13e9	c8		iny				iny
.13ea	b1 0c		lda ($0c),y			lda 	(temp0),y
.13ec	85 0d		sta $0d				sta 	temp0+1
.13ee	86 0c		stx $0c				stx 	temp0
.13f0	60		rts				rts
.13f1					LoadIndirectTemp0:
.13f1	a0 00		ldy #$00			ldy 	#0							; low byte into X
.13f3	b1 0c		lda ($0c),y			lda 	(temp0),y
.13f5	aa		tax				tax
.13f6	c8		iny				iny
.13f7	b1 0c		lda ($0c),y			lda 	(temp0),y 					; high byte into A
.13f9	85 0d		sta $0d				sta 	temp0+1 					; copy out.
.13fb	86 0c		stx $0c				stx 	temp0
.13fd	60		rts				rts
.13fe					EndMulDivContent:

;******  Return to file: runtime.asm


;******  Processing file: utility.asm

>13fe	2c 00					.word 	EndVariableClear-* 							; offset to next entry
>1400	63 6c 65 61 72 2e 76 61			.text 	"clear.variables:0",0 							; the text (must be lower case)
>1408	72 69 61 62 6c 65 73 3a 30 00
>1412						.align 	2								; force to even boundary.
.1412					VariableClear:
.1412	a9 00		lda #$00			lda 	#VarAddr & $FF
.1414	85 0c		sta $0c				sta 	temp0
.1416	a9 08		lda #$08			lda 	#VarAddr >> 8
.1418	85 0d		sta $0d				sta		temp0+1
.141a	a2 08		ldx #$08			ldx 	#VarPages
.141c	a0 00		ldy #$00			ldy 	#0
.141e	98		tya				tya
.141f	91 0c		sta ($0c),y	_VCLoop:sta 	(temp0),y
.1421	c8		iny				iny
.1422	d0 fb		bne $141f			bne 	_VCLoop
.1424	e6 0d		inc $0d				inc 	temp0+1
.1426	ca		dex				dex
.1427	d0 f6		bne $141f			bne 	_VCLoop
.1429	60		rts				rts
.142a					EndVariableClear:
>142a	13 00					.word 	EndHaltProgram-* 							; offset to next entry
>142c	68 61 6c 74 2e 70 72 6f			.text 	"halt.program",0 							; the text (must be lower case)
>1434	67 72 61 6d 00
>1439						.align 	2								; force to even boundary.
.143a					HaltProgram:
.143a	4c 3a 14	jmp $143a			jmp 	HaltProgram
.143d					EndHaltProgram:
>143d	19 00					.word 	EndPrintCharacter-* 							; offset to next entry
>143f	70 72 69 6e 74 2e 63 68			.text 	"print.character:1",0 							; the text (must be lower case)
>1447	61 72 61 63 74 65 72 3a 31 00
>1451						.align 	2								; force to even boundary.
.1452					PrintCharacter:
.1452	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1455	60		rts				rts
.1456					EndPrintCharacter:
>1456	2f 00					.word 	EndPrintHex-* 							; offset to next entry
>1458	70 72 69 6e 74 2e 68 65			.text 	"print.hex:1",0 							; the text (must be lower case)
>1460	78 3a 31 00
>1464						.align 	2								; force to even boundary.
.1464					PrintHex:
.1464	48		pha				pha
.1465	a9 20		lda #$20			lda 	#32
.1467	20 52 14	jsr $1452			jsr 	PrintCharacter
.146a	8a		txa				txa
.146b	20 6f 14	jsr $146f			jsr 	_PHex
.146e	68		pla				pla
.146f	48		pha		_PHex:	pha
.1470	4a		lsr a				lsr 	a
.1471	4a		lsr a				lsr 	a
.1472	4a		lsr a				lsr 	a
.1473	4a		lsr a				lsr 	a
.1474	20 78 14	jsr $1478			jsr 	_PNibl
.1477	68		pla				pla
.1478	29 0f		and #$0f	_PNibl:	and 	#15
.147a	c9 0a		cmp #$0a			cmp 	#10
.147c	90 02		bcc $1480			bcc 	_PNoSkip
.147e	69 06		adc #$06			adc 	#6
.1480					_PNoSkip:
.1480	69 30		adc #$30			adc 	#48
.1482	4c 52 14	jmp $1452			jmp 	PrintCharacter
.1485					EndPrintHex:
>1485	22 00					.word 	EndPrintString-* 							; offset to next entry
>1487	70 72 69 6e 74 2e 73 74			.text 	"print.string:1",0 							; the text (must be lower case)
>148f	72 69 6e 67 3a 31 00
>1496						.align 	2								; force to even boundary.
.1496					PrintString:
.1496	85 0c		sta $0c				sta 	temp0
.1498	86 0d		stx $0d				stx 	temp0+1
.149a	a0 00		ldy #$00			ldy 	#0
.149c	b1 0c		lda ($0c),y	_PSLoop:lda 	(temp0),y
.149e	f0 06		beq $14a6			beq 	_PSExit
.14a0	20 52 14	jsr $1452			jsr 	PrintCharacter
.14a3	c8		iny				iny
.14a4	d0 f6		bne $149c			bne 	_PSLoop
.14a6	60		rts		_PSExit:rts
.14a7					EndPrintString

;******  Return to file: runtime.asm

.14a7					RuntimeEnd:

;******  End of listing
