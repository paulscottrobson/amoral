
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D test=1 --m6502 -o runtime.prg -L runtime.lst runtime.asm
; Sat Nov 14 06:52:26 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					test=1

;******  Processing input file: runtime.asm


;******  Processing file: macros.asm


;******  Return to file: runtime.asm

=$1000					RunTimeAddress = $1000 						; Runtime loads at this address (e.g. Boot)
=$c00					VariableMemory = $C00 						; Variable memory here (128 per 1/4k) PAGE BOUNDARY.
=$08					ZeroPageBase = $08 							; Zero page goes here.
=$08					Reg16 = ZeroPageBase 						; the current value register.
=10					Pctr = ZeroPageBase+2 						; the program counter (e.g. the next instruction)
=12					temp0 = ZeroPageBase+4 						; temporary registers
=14					temp1 = ZeroPageBase+6
.1000	4c 52 12	jmp $1252			jmp 	TestRuntimeCode 			; test=1 runs code build with rasm.py
.1003	4c 00 10	jmp $1000			jmp 	RunTimeAddress 				; what we normally get.
>101a	00 10						.word 	RunTimeAddress 				; the address of boot
>101c	62 12						.word	RunTimeEnd 					; where the runtime ends (e.g. where code goes)
>101e	00 00						.word 	$0000 						; address of allocatable memory (set up by compiler)

;******  Processing file: interpreter.asm

>1020	42 02					.word 	EndRunPCode-* 							; offset to next entry
>1022	72 75 6e 70 63 6f 64 65			.text 	"runpcode",0 							; the text (must be lower case)
>102a	00
>102b						.align 	2								; force to even boundary.
.102c					RunPCode:
.102c	86 09		stx $09				stx 	Reg16+1 					; save the current XA values.
.102e	85 08		sta $08				sta 	Reg16
.1030	68		pla				pla 								; pull the address into the PC
.1031	85 0a		sta $0a				sta 	Pctr
.1033	68		pla				pla
.1034	85 0b		sta $0b				sta 	Pctr+1
.1036	e6 0a		inc $0a			inc 	Pctr
.1038	d0 02		bne $103c		bne 	nocarry
.103a	e6 0b		inc $0b			inc 	1+(Pctr)
.103c					nocarry:
.103c					ExecLoop:
>103c	db					.byte 	$DB
.103d	a0 00		ldy #$00			ldy 	#0							; get the next instruction
.103f	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1041	e6 0a		inc $0a			inc 	Pctr
.1043	d0 02		bne $1047		bne 	nocarry
.1045	e6 0b		inc $0b			inc 	1+(Pctr)
.1047					nocarry:
.1047	0a		asl a				asl 	a 							; shift bit 7 into carry.
.1048	b0 29		bcs $1073			bcs 	CommandHandler 				; 80-FF it's a command
.104a	85 0c		sta $0c				sta 	temp0 						; construct the call address in temp0
.104c	b1 0a		lda ($0a),y			lda 	(PCtr),y 					; get the MSB
.104e	85 0d		sta $0d				sta 	temp0+1
.1050	e6 0a		inc $0a			inc 	Pctr
.1052	d0 02		bne $1056		bne 	nocarry
.1054	e6 0b		inc $0b			inc 	1+(Pctr)
.1056					nocarry:
.1056	a5 0a		lda $0a				lda 	Pctr 						; save PCTR on 6502 stack
.1058	48		pha				pha
.1059	a5 0b		lda $0b				lda 	Pctr+1
.105b	48		pha				pha
.105c	a5 08		lda $08				lda 	Reg16 						; restore Reg16 into XA
.105e	a6 09		ldx $09				ldx 	Reg16+1
.1060	20 70 10	jsr $1070			jsr 	CallTemp0 					; call the routine as 6502 code.
.1063	86 09		stx $09				stx 	Reg16+1 					; save Reg16 back
.1065	85 08		sta $08				sta 	Reg16
.1067	68		pla				pla 								; restore the program counter
.1068	85 0b		sta $0b				sta 	Pctr+1
.106a	68		pla				pla
.106b	85 0a		sta $0a				sta 	Pctr
.106d	4c 3c 10	jmp $103c			jmp 	ExecLoop 					; and go round again.
.1070					CallTemp0:
.1070	6c 0c 00	jmp ($000c)			jmp 	(temp0)
.1073					CommandHandler:
.1073	6a		ror a				ror 	a 							; patch it back so it has the full opcode.
.1074	a8		tay				tay  								; save it in Y for use by the commands.
.1075	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a unary operation.
.1077	b0 05		bcs $107e			bcs 	_CHIsUnary
.1079	29 0f		and #$0f			and 	#$0F 						; get the command number out.
.107b	4c 82 10	jmp $1082			jmp 	_CHCall 					; go do the call
.107e					_CHIsUnary:
.107e	29 0f		and #$0f			and 	#$0F 						; this is the unary command number
.1080	09 10		ora #$10			ora 	#$10 						; mapped onto $10-$1F
.1082					_CHCall:
.1082	0a		asl a				asl 	a 							; now offset in the jump table and into X
.1083	aa		tax				tax
.1084	bd 94 10	lda $1094,x			lda 	JumpTable,x 				; copy the jump table vectors into temp0
.1087	85 0c		sta $0c				sta 	temp0
.1089	bd 95 10	lda $1095,x			lda 	JumpTable+1,x
.108c	85 0d		sta $0d				sta 	temp0+1
.108e	6c 0c 00	jmp ($000c)			jmp 	(temp0)						; and go there to execute with the opcode in Y.
.1091					OpcodeError:
.1091	a2 ee		ldx #$ee			ldx 	#$EE 						; EE = Error :)
>1093	db					.byte 	$DB
.1094					JumpTable:

;******  Processing file: generated/jumptable.inc

>1094	d4 10					.word LoadHandler              ; $80 LDR
>1096	19 11					.word Andhandler               ; $81 AND
>1098	2b 11					.word Orhandler                ; $82 ORR
>109a	3d 11					.word Xorhandler               ; $83 XOR
>109c	f3 10					.word Addhandler               ; $84 ADD
>109e	06 11					.word Subhandler               ; $85 SUB
>10a0	cc 11					.word MultiplyHandler          ; $86 MLT
>10a2	01 12					.word DivideHandler            ; $87 DIV
>10a4	1a 12					.word ModulusHandler           ; $88 MOD
>10a6	91 10					.word OpcodeError              ; $89 ?
>10a8	e2 10					.word StoreHandler             ; $8a STR
>10aa	91 10					.word OpcodeError              ; $8b ?
>10ac	91 10					.word OpcodeError              ; $8c ?
>10ae	91 10					.word OpcodeError              ; $8d ?
>10b0	91 10					.word OpcodeError              ; $8e ?
>10b2	91 10					.word OpcodeError              ; $8f ?
>10b4	91 10					.word OpcodeError              ; $f0 ?
>10b6	91 10					.word OpcodeError              ; $f1 ?
>10b8	91 10					.word OpcodeError              ; $f2 ?
>10ba	91 10					.word OpcodeError              ; $f3 ?
>10bc	91 10					.word OpcodeError              ; $f4 ?
>10be	91 10					.word OpcodeError              ; $f5 ?
>10c0	91 10					.word OpcodeError              ; $f6 ?
>10c2	91 10					.word OpcodeError              ; $f7 ?
>10c4	91 10					.word OpcodeError              ; $f8 ?
>10c6	91 10					.word OpcodeError              ; $f9 ?
>10c8	91 10					.word OpcodeError              ; $fa ?
>10ca	91 10					.word OpcodeError              ; $fb ?
>10cc	91 10					.word OpcodeError              ; $fc ?
>10ce	91 10					.word OpcodeError              ; $fd ?
>10d0	91 10					.word OpcodeError              ; $fe ?
>10d2	91 10					.word OpcodeError              ; $ff ?

;******  Return to file: interpreter.asm


;******  Return to file: runtime.asm


;******  Processing file: commands.asm

.10d4					LoadHandler:
.10d4	20 4f 11	jsr $114f			jsr 	EvaluateValue 				; temp0 = target value.
.10d7	a5 0c		lda $0c				lda 	temp0						; copy value into register
.10d9	85 08		sta $08				sta 	Reg16
.10db	a5 0d		lda $0d				lda 	temp0+1
.10dd	85 09		sta $09				sta 	Reg16+1
.10df	4c 3c 10	jmp $103c			jmp 	ExecLoop
.10e2					StoreHandler:
.10e2	20 84 11	jsr $1184			jsr 	EvaluateAddress 			; temp0 = target address.
.10e5	a0 00		ldy #$00			ldy 	#0							; write register out
.10e7	a5 08		lda $08				lda 	Reg16
.10e9	91 0c		sta ($0c),y			sta 	(temp0),y
.10eb	a5 09		lda $09				lda 	Reg16+1
.10ed	c8		iny				iny
.10ee	91 0c		sta ($0c),y			sta 	(temp0),y
.10f0	4c 3c 10	jmp $103c			jmp 	ExecLoop
.10f3					Addhandler:
.10f3	20 4f 11	jsr $114f			jsr 	EvaluateValue
.10f6	18		clc				clc
.10f7	a5 08		lda $08				lda 	Reg16
.10f9	65 0c		adc $0c				adc 	temp0
.10fb	85 08		sta $08				sta 	Reg16
.10fd	a5 09		lda $09				lda 	Reg16+1
.10ff	65 0d		adc $0d				adc 	temp0+1
.1101	85 09		sta $09				sta 	Reg16+1
.1103	4c 3c 10	jmp $103c			jmp 	ExecLoop
.1106					Subhandler:
.1106	20 4f 11	jsr $114f			jsr 	EvaluateValue
.1109	38		sec				sec
.110a	a5 08		lda $08				lda 	Reg16
.110c	e5 0c		sbc $0c				sbc 	temp0
.110e	85 08		sta $08				sta 	Reg16
.1110	a5 09		lda $09				lda 	Reg16+1
.1112	e5 0d		sbc $0d				sbc 	temp0+1
.1114	85 09		sta $09				sta 	Reg16+1
.1116	4c 3c 10	jmp $103c			jmp 	ExecLoop
.1119					Andhandler:
.1119	20 4f 11	jsr $114f			jsr 	EvaluateValue
.111c	a5 08		lda $08				lda 	Reg16
.111e	25 0c		and $0c				and 	temp0
.1120	85 08		sta $08				sta 	Reg16
.1122	a5 09		lda $09				lda 	Reg16+1
.1124	25 0d		and $0d				and 	temp0+1
.1126	85 09		sta $09				sta 	Reg16+1
.1128	4c 3c 10	jmp $103c			jmp 	ExecLoop
.112b					Orhandler:
.112b	20 4f 11	jsr $114f			jsr 	EvaluateValue
.112e	a5 08		lda $08				lda 	Reg16
.1130	05 0c		ora $0c				ora 	temp0
.1132	85 08		sta $08				sta 	Reg16
.1134	a5 09		lda $09				lda 	Reg16+1
.1136	05 0d		ora $0d				ora 	temp0+1
.1138	85 09		sta $09				sta 	Reg16+1
.113a	4c 3c 10	jmp $103c			jmp 	ExecLoop
.113d					Xorhandler:
.113d	20 4f 11	jsr $114f			jsr 	EvaluateValue
.1140	a5 08		lda $08				lda 	Reg16
.1142	45 0c		eor $0c				eor 	temp0
.1144	85 08		sta $08				sta 	Reg16
.1146	a5 09		lda $09				lda 	Reg16+1
.1148	45 0d		eor $0d				eor 	temp0+1
.114a	85 09		sta $09				sta 	Reg16+1
.114c	4c 3c 10	jmp $103c			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: support.asm

.114f					EvaluateValue:
.114f	98		tya				tya 								; get EAC part and save in X
.1150	29 70		and #$70			and 	#$70
.1152	aa		tax				tax
.1153	c9 20		cmp #$20			cmp 	#$20 						; check if 00,01 if so it is variable or absolute
.1155	b0 1d		bcs $1174			bcs 	_EDMemory
.1157	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1159	b1 0a		lda ($0a),y			lda 	(Pctr),y
.115b	85 0c		sta $0c				sta 	temp0
.115d	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.115f	e6 0a		inc $0a			inc 	Pctr
.1161	d0 02		bne $1165		bne 	nocarry
.1163	e6 0b		inc $0b			inc 	1+(Pctr)
.1165					nocarry:
.1165	e0 00		cpx #$00			cpx 	#0 							; if it is 000 then it is a one byte
.1167	f0 0a		beq $1173			beq 	_EACalcValue
.1169	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.116b	85 0d		sta $0d				sta 	temp0+1
.116d	e6 0a		inc $0a			inc 	Pctr
.116f	d0 02		bne $1173		bne 	nocarry
.1171	e6 0b		inc $0b			inc 	1+(Pctr)
.1173					nocarry:
.1173					_EACalcValue:
.1173	60		rts				rts
.1174					_EDMemory:
.1174	20 84 11	jsr $1184			jsr	 	EvaluateAddress 			; evaluate the address.
.1177	a0 00		ldy #$00			ldy 	#0 							; 16 bit load indirect (temp0) => temp0
.1179	b1 0c		lda ($0c),y			lda 	(temp0),y
.117b	aa		tax				tax
.117c	c8		iny				iny
.117d	b1 0c		lda ($0c),y			lda 	(temp0),y
.117f	86 0c		stx $0c				stx 	temp0
.1181	85 0d		sta $0d				sta 	temp0+1
.1183	60		rts				rts
.1184					EvaluateAddress:
.1184	98		tya				tya 								; get EAC part of opcode.
.1185	29 70		and #$70			and 	#$70
.1187	c9 40		cmp #$40			cmp 	#$40 						; is it an absolute address
.1189	f0 29		beq $11b4			beq 	_EAAbsolute
.118b	aa		tax				tax 								; save in X
.118c	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.118e	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1190	85 0c		sta $0c				sta 	temp0
.1192	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1194	e6 0a		inc $0a			inc 	Pctr
.1196	d0 02		bne $119a		bne 	nocarry
.1198	e6 0b		inc $0b			inc 	1+(Pctr)
.119a					nocarry:
.119a	e0 20		cpx #$20			cpx 	#$20 						; if it is 010 then it is a one byte
.119c	f0 0a		beq $11a8			beq 	_EACalcVarAddress
.119e	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.11a0	85 0d		sta $0d				sta 	temp0+1
.11a2	e6 0a		inc $0a			inc 	Pctr
.11a4	d0 02		bne $11a8		bne 	nocarry
.11a6	e6 0b		inc $0b			inc 	1+(Pctr)
.11a8					nocarry:
.11a8					_EACalcVarAddress:
.11a8	06 0c		asl $0c				asl 	temp0 						; double the variable number
.11aa	26 0d		rol $0d				rol 	temp0+1
.11ac	18		clc				clc 								; add the page address of variable data on.
.11ad	a5 0d		lda $0d				lda 	temp0+1
.11af	69 0c		adc #$0c			adc 	#VariableMemory/256
.11b1	85 0d		sta $0d				sta 	temp0+1
.11b3	60		rts				rts
.11b4					_EAAbsolute:
.11b4	a0 00		ldy #$00			ldy 	#0 							; get the address into temp0
.11b6	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11b8	85 0c		sta $0c				sta 	temp0
.11ba	c8		iny				iny
.11bb	b1 0a		lda ($0a),y			lda 	(Pctr),y
.11bd	85 0d		sta $0d				sta 	temp0+1
.11bf					ReturnBump2
.11bf	e6 0a		inc $0a			inc 	Pctr
.11c1	d0 02		bne $11c5		bne 	nocarry
.11c3	e6 0b		inc $0b			inc 	1+(Pctr)
.11c5					nocarry:
.11c5					ReturnBump1:
.11c5	e6 0a		inc $0a			inc 	Pctr
.11c7	d0 02		bne $11cb		bne 	nocarry
.11c9	e6 0b		inc $0b			inc 	1+(Pctr)
.11cb					nocarry:
.11cb	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: multiply.asm

.11cc					MultiplyHandler:
.11cc	20 4f 11	jsr $114f			jsr 	EvaluateValue 				; temp0 = target value.
.11cf	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.11d1	85 0e		sta $0e				sta 	temp1
.11d3	a5 09		lda $09				lda	 	Reg16+1
.11d5	85 0f		sta $0f				sta 	temp1+1
.11d7	20 dd 11	jsr $11dd			jsr 	Multiply 					; Reg16 := temp0 * temp1
.11da	4c 3c 10	jmp $103c			jmp 	ExecLoop
.11dd					Multiply:
.11dd	a9 00		lda #$00			lda 	#0 							; zero total.
.11df	85 08		sta $08				sta 	Reg16
.11e1	85 09		sta $09				sta 	Reg16+1
.11e3					_MultLoop:
.11e3	46 0d		lsr $0d				lsr 	temp0+1
.11e5	66 0c		ror $0c				ror 	temp0
.11e7	90 0d		bcc $11f6			bcc 	_MultNoAdd
.11e9	18		clc				clc
.11ea	a5 0e		lda $0e				lda 	temp1
.11ec	65 08		adc $08				adc 	Reg16
.11ee	85 08		sta $08				sta 	Reg16
.11f0	a5 0f		lda $0f				lda 	temp1+1
.11f2	65 09		adc $09				adc 	Reg16+1
.11f4	85 09		sta $09				sta 	Reg16+1
.11f6					_MultNoAdd:
.11f6	06 0e		asl $0e				asl 	temp1
.11f8	26 0f		rol $0f				rol 	temp1+1
.11fa	a5 0c		lda $0c				lda 	temp0
.11fc	05 0d		ora $0d				ora 	temp0+1
.11fe	d0 e3		bne $11e3			bne 	_MultLoop
.1200	60		rts				rts

;******  Return to file: runtime.asm


;******  Processing file: divide.asm

.1201					DivideHandler:
.1201	20 4f 11	jsr $114f			jsr 	EvaluateValue 				; temp0 = target value.
.1204	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.1206	85 0e		sta $0e				sta 	temp1
.1208	a5 09		lda $09				lda	 	Reg16+1
.120a	85 0f		sta $0f				sta 	temp1+1
.120c	20 2b 12	jsr $122b			jsr 	Divide 						; temp1 := temp1 / temp0
.120f	a5 0e		lda $0e				lda 	temp1 						; copy result into register
.1211	85 08		sta $08				sta 	Reg16
.1213	a5 0f		lda $0f				lda 	temp1+1
.1215	85 09		sta $09				sta 	Reg16+1
.1217	4c 3c 10	jmp $103c			jmp 	ExecLoop
.121a					ModulusHandler:
.121a	20 4f 11	jsr $114f			jsr 	EvaluateValue 				; temp0 = target value.
.121d	a5 08		lda $08				lda 	Reg16 						; temp1 = reg16
.121f	85 0e		sta $0e				sta 	temp1
.1221	a5 09		lda $09				lda	 	Reg16+1
.1223	85 0f		sta $0f				sta 	temp1+1
.1225	20 2b 12	jsr $122b			jsr 	Divide 						; temp1 := temp1 / temp0, mod => Reg16
.1228	4c 3c 10	jmp $103c			jmp 	ExecLoop
.122b					Divide:
.122b	a9 00		lda #$00			lda 	#0 							; set A = 0
.122d	85 08		sta $08				sta 	Reg16
.122f	85 09		sta $09				sta 	Reg16+1
.1231	a0 10		ldy #$10			ldy 	#16 						; loop round 16 times.
.1233					_DivLoop:
.1233	06 0e		asl $0e				asl 	temp1 						; shift QA left. Q first
.1235	26 0f		rol $0f				rol 	temp1+1
.1237	26 08		rol $08				rol 	Reg16 						; shift A left carrying in.
.1239	26 09		rol $09				rol 	Reg16+1
.123b	38		sec				sec 								; calculate A-M, result in XA/C
.123c	a5 08		lda $08				lda 	Reg16
.123e	e5 0c		sbc $0c				sbc 	temp0
.1240	aa		tax				tax
.1241	a5 09		lda $09				lda 	Reg16+1
.1243	e5 0d		sbc $0d				sbc 	temp0+1
.1245	90 06		bcc $124d			bcc 	_DivNoUpdate 				; if A >= M then store result and set Q bit 0.
.1247	85 09		sta $09				sta 	Reg16+1
.1249	86 08		stx $08				stx 	Reg16
.124b	e6 0e		inc $0e				inc 	temp1 						; we know it is even.
.124d					_DivNoUpdate:
.124d	88		dey				dey
.124e	d0 e3		bne $1233			bne 	_DivLoop
>1250	db					.byte 	$DB
.1251	60		rts				rts

;******  Return to file: runtime.asm

.1252					TestRuntimeCode:
.1252	a2 ab		ldx #$ab			ldx 	#$AB 						; something to work with
.1254	a9 cd		lda #$cd			lda 	#$CD
.1256	20 2c 10	jsr $102c			jsr 	RunPCode 					; go do the following code.

;******  Processing file: generated/testasm.inc

.1259					TEST_count:
>1259	90 17 27				.byte $90,$17,$27                              ; ldr #10007
>125c	88 0a					.byte $88,$0a                                  ; mod #10
>125e	aa 02					.byte $aa,$02                                  ; str [2]
>1260	ff					.byte $ff                                      ; halt

;******  Return to file: runtime.asm

>1261	db					.byte 	$DB
.1262					EndRunPCode:
.1262					RuntimeEnd:
>1262	00 00						.word 	0 							; end marker for dictionary.

;******  End of listing
