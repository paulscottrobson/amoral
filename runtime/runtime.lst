
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass --m6502 -o runtime.prg -L runtime.lst runtime.asm
; Fri Nov 13 21:45:05 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: runtime.asm


;******  Processing file: macros.asm


;******  Return to file: runtime.asm

=$1000					RunTimeAddress = $1000 						; Runtime loads at this address (e.g. Boot)
=$c00					VariableMemory = $C00 						; Variable memory here (128 per 1/4k) PAGE BOUNDARY.
=$08					ZeroPageBase = $08 							; Zero page goes here.
=$08					Reg16 = ZeroPageBase 						; the current value register.
=10					Pctr = ZeroPageBase+2 						; the program counter (e.g. the next instruction)
=12					temp0 = ZeroPageBase+4 						; temporary registers
.1000	a9 60		lda #$60			lda 	#$60
.1002	a2 4a		ldx #$4a			ldx 	#$4A
.1004	20 2c 10	jsr $102c			jsr 	RunPCode
>1007	90 3c 57					.byte 	$90,$3C,$57
>100a	ba 02 01					.byte 	$BA,$02,$01
>100d	80 fe						.byte 	$80,$FE
>100f	ca 80 08					.byte 	$CA,$80,$08
>1012	b0 02 01					.byte 	$B0,$02,$01
>1015	c0 80 08					.byte 	$C0,$80,$08
>1018	89						.byte 	$89
>101a	00 10						.word 	RunTimeAddress 				; the address of boot
>101c	6e 11						.word	RunTimeEnd 					; where the runtime ends (e.g. where code goes)
>101e	00 00						.word 	$0000 						; address of allocatable memory (set up by compiler)

;******  Processing file: interpreter.asm

>1020	4e 01					.word 	EndRunPCode-* 							; offset to next entry
>1022	72 75 6e 70 63 6f 64 65			.text 	"runpcode",0 							; the text (must be lower case)
>102a	00
>102b						.align 	2								; force to even boundary.
.102c					RunPCode:
.102c	86 09		stx $09				stx 	Reg16+1 					; save the current XA values.
.102e	85 08		sta $08				sta 	Reg16
.1030	68		pla				pla 								; pull the address into the PC
.1031	85 0a		sta $0a				sta 	Pctr
.1033	68		pla				pla
.1034	85 0b		sta $0b				sta 	Pctr+1
.1036	e6 0a		inc $0a			inc 	Pctr
.1038	d0 02		bne $103c		bne 	nocarry
.103a	e6 0b		inc $0b			inc 	1+(Pctr)
.103c					nocarry:
.103c					ExecLoop:
.103c	a0 00		ldy #$00			ldy 	#0							; get the next instruction
.103e	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1040	e6 0a		inc $0a			inc 	Pctr
.1042	d0 02		bne $1046		bne 	nocarry
.1044	e6 0b		inc $0b			inc 	1+(Pctr)
.1046					nocarry:
.1046	0a		asl a				asl 	a 							; shift bit 7 into carry.
.1047	b0 29		bcs $1072			bcs 	CommandHandler 				; 80-FF it's a command
.1049	85 0c		sta $0c				sta 	temp0 						; construct the call address in temp0
.104b	b1 0a		lda ($0a),y			lda 	(PCtr),y 					; get the MSB
.104d	85 0d		sta $0d				sta 	temp0+1
.104f	e6 0a		inc $0a			inc 	Pctr
.1051	d0 02		bne $1055		bne 	nocarry
.1053	e6 0b		inc $0b			inc 	1+(Pctr)
.1055					nocarry:
.1055	a5 0a		lda $0a				lda 	Pctr 						; save PCTR on 6502 stack
.1057	48		pha				pha
.1058	a5 0b		lda $0b				lda 	Pctr+1
.105a	48		pha				pha
.105b	a5 08		lda $08				lda 	Reg16 						; restore Reg16 into XA
.105d	a6 09		ldx $09				ldx 	Reg16+1
.105f	20 6f 10	jsr $106f			jsr 	CallTemp0 					; call the routine as 6502 code.
.1062	86 09		stx $09				stx 	Reg16+1 					; save Reg16 back
.1064	85 08		sta $08				sta 	Reg16
.1066	68		pla				pla 								; restore the program counter
.1067	85 0b		sta $0b				sta 	Pctr+1
.1069	68		pla				pla
.106a	85 0a		sta $0a				sta 	Pctr
.106c	4c 3c 10	jmp $103c			jmp 	ExecLoop 					; and go round again.
.106f					CallTemp0:
.106f	6c 0c 00	jmp ($000c)			jmp 	(temp0)
.1072					CommandHandler:
.1072	6a		ror a				ror 	a 							; patch it back so it has the full opcode.
.1073	a8		tay				tay  								; save it in Y for use by the commands.
.1074	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a unary operation.
.1076	b0 05		bcs $107d			bcs 	_CHIsUnary
.1078	29 0f		and #$0f			and 	#$0F 						; get the command number out.
.107a	4c 81 10	jmp $1081			jmp 	_CHCall 					; go do the call
.107d					_CHIsUnary:
.107d	29 0f		and #$0f			and 	#$0F 						; this is the unary command number
.107f	09 10		ora #$10			ora 	#$10 						; mapped onto $10-$1F
.1081					_CHCall:
.1081	0a		asl a				asl 	a 							; now offset in the jump table and into X
.1082	aa		tax				tax
.1083	bd 91 10	lda $1091,x			lda 	JumpTable,x 				; copy the jump table vectors into temp0
.1086	85 0c		sta $0c				sta 	temp0
.1088	bd 92 10	lda $1092,x			lda 	JumpTable+1,x
.108b	85 0d		sta $0d				sta 	temp0+1
.108d	6c 0c 00	jmp ($000c)			jmp 	(temp0)						; and go there to execute with the opcode in Y.
.1090					OpcodeError:
>1090	db					.byte 	$DB
.1091					JumpTable:

;******  Processing file: generated/jumptable.inc

>1091	d1 10					.word LoadHandler              ; $80 LDR
>1093	90 10					.word OpcodeError              ; $81 ?
>1095	90 10					.word OpcodeError              ; $82 ?
>1097	90 10					.word OpcodeError              ; $83 ?
>1099	90 10					.word OpcodeError              ; $84 ?
>109b	90 10					.word OpcodeError              ; $85 ?
>109d	90 10					.word OpcodeError              ; $86 ?
>109f	90 10					.word OpcodeError              ; $87 ?
>10a1	90 10					.word OpcodeError              ; $88 ?
>10a3	90 10					.word OpcodeError              ; $89 ?
>10a5	df 10					.word StoreHandler             ; $8a STR
>10a7	90 10					.word OpcodeError              ; $8b ?
>10a9	90 10					.word OpcodeError              ; $8c ?
>10ab	90 10					.word OpcodeError              ; $8d ?
>10ad	90 10					.word OpcodeError              ; $8e ?
>10af	90 10					.word OpcodeError              ; $8f ?
>10b1	90 10					.word OpcodeError              ; $f0 ?
>10b3	90 10					.word OpcodeError              ; $f1 ?
>10b5	90 10					.word OpcodeError              ; $f2 ?
>10b7	90 10					.word OpcodeError              ; $f3 ?
>10b9	90 10					.word OpcodeError              ; $f4 ?
>10bb	90 10					.word OpcodeError              ; $f5 ?
>10bd	90 10					.word OpcodeError              ; $f6 ?
>10bf	90 10					.word OpcodeError              ; $f7 ?
>10c1	90 10					.word OpcodeError              ; $f8 ?
>10c3	90 10					.word OpcodeError              ; $f9 ?
>10c5	90 10					.word OpcodeError              ; $fa ?
>10c7	90 10					.word OpcodeError              ; $fb ?
>10c9	90 10					.word OpcodeError              ; $fc ?
>10cb	90 10					.word OpcodeError              ; $fd ?
>10cd	90 10					.word OpcodeError              ; $fe ?
>10cf	90 10					.word OpcodeError              ; $ff ?

;******  Return to file: interpreter.asm


;******  Return to file: runtime.asm


;******  Processing file: commands.asm

.10d1					LoadHandler:
.10d1	20 f0 10	jsr $10f0			jsr 	EvaluateValue 				; temp0 = target value.
.10d4	a5 0c		lda $0c				lda 	temp0						; copy value into register
.10d6	85 08		sta $08				sta 	Reg16
.10d8	a5 0d		lda $0d				lda 	temp0+1
.10da	85 09		sta $09				sta 	Reg16+1
.10dc	4c 3c 10	jmp $103c			jmp 	ExecLoop
.10df					StoreHandler:
.10df	20 26 11	jsr $1126			jsr 	EvaluateAddress 			; temp0 = target address.
.10e2	a0 00		ldy #$00			ldy 	#0							; write register out
.10e4	a5 08		lda $08				lda 	Reg16
.10e6	91 0c		sta ($0c),y			sta 	(temp0),y
.10e8	a5 09		lda $09				lda 	Reg16+1
.10ea	c8		iny				iny
.10eb	91 0c		sta ($0c),y			sta 	(temp0),y
.10ed	4c 3c 10	jmp $103c			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: support.asm

.10f0					EvaluateValue:
.10f0	98		tya				tya 								; get EAC part and save in X
.10f1	29 70		and #$70			and 	#$70
.10f3	aa		tax				tax
.10f4	c9 20		cmp #$20			cmp 	#$20 						; check if 00,01 if so it is variable or absolute
.10f6	b0 1d		bcs $1115			bcs 	_EDMemory
.10f8	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.10fa	b1 0a		lda ($0a),y			lda 	(Pctr),y
.10fc	85 0c		sta $0c				sta 	temp0
.10fe	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1100	e6 0a		inc $0a			inc 	Pctr
.1102	d0 02		bne $1106		bne 	nocarry
.1104	e6 0b		inc $0b			inc 	1+(Pctr)
.1106					nocarry:
.1106	e0 00		cpx #$00			cpx 	#0 							; if it is 000 then it is a one byte
.1108	f0 0a		beq $1114			beq 	_EACalcValue
.110a	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.110c	85 0d		sta $0d				sta 	temp0+1
.110e	e6 0a		inc $0a			inc 	Pctr
.1110	d0 02		bne $1114		bne 	nocarry
.1112	e6 0b		inc $0b			inc 	1+(Pctr)
.1114					nocarry:
.1114					_EACalcValue:
.1114	60		rts				rts
.1115					_EDMemory:
>1115	db					.byte 	$DB
.1116	20 26 11	jsr $1126			jsr	 	EvaluateAddress 			; evaluate EAC.
.1119	a0 00		ldy #$00			ldy 	#0 							; 16 bit load indirect (temp0) => temp0
.111b	b1 0c		lda ($0c),y			lda 	(temp0),y
.111d	aa		tax				tax
.111e	c8		iny				iny
.111f	b1 0c		lda ($0c),y			lda 	(temp0),y
.1121	86 0c		stx $0c				stx 	temp0
.1123	85 0d		sta $0d				sta 	temp0+1
.1125	60		rts				rts
.1126					EvaluateAddress:
.1126	98		tya				tya 								; get EAC part of opcode.
.1127	29 70		and #$70			and 	#$70
.1129	c9 40		cmp #$40			cmp 	#$40 						; is it an absolute address
.112b	f0 29		beq $1156			beq 	_EAAbsolute
.112d	aa		tax				tax 								; save in X
.112e	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1130	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1132	85 0c		sta $0c				sta 	temp0
.1134	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1136	e6 0a		inc $0a			inc 	Pctr
.1138	d0 02		bne $113c		bne 	nocarry
.113a	e6 0b		inc $0b			inc 	1+(Pctr)
.113c					nocarry:
.113c	e0 20		cpx #$20			cpx 	#$20 						; if it is 010 then it is a one byte
.113e	f0 0a		beq $114a			beq 	_EACalcVarAddress
.1140	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.1142	85 0d		sta $0d				sta 	temp0+1
.1144	e6 0a		inc $0a			inc 	Pctr
.1146	d0 02		bne $114a		bne 	nocarry
.1148	e6 0b		inc $0b			inc 	1+(Pctr)
.114a					nocarry:
.114a					_EACalcVarAddress:
.114a	06 0c		asl $0c				asl 	temp0 						; double the variable number
.114c	26 0d		rol $0d				rol 	temp0+1
.114e	18		clc				clc 								; add the page address of variable data on.
.114f	a5 0d		lda $0d				lda 	temp0+1
.1151	69 0c		adc #$0c			adc 	#VariableMemory/256
.1153	85 0d		sta $0d				sta 	temp0+1
.1155	60		rts				rts
.1156					_EAAbsolute:
.1156	a0 00		ldy #$00			ldy 	#0 							; get the address into temp0
.1158	b1 0a		lda ($0a),y			lda 	(Pctr),y
.115a	85 0c		sta $0c				sta 	temp0
.115c	c8		iny				iny
.115d	b1 0a		lda ($0a),y			lda 	(Pctr),y
.115f	85 0d		sta $0d				sta 	temp0+1
.1161					ReturnBump2
.1161	e6 0a		inc $0a			inc 	Pctr
.1163	d0 02		bne $1167		bne 	nocarry
.1165	e6 0b		inc $0b			inc 	1+(Pctr)
.1167					nocarry:
.1167					ReturnBump1:
.1167	e6 0a		inc $0a			inc 	Pctr
.1169	d0 02		bne $116d		bne 	nocarry
.116b	e6 0b		inc $0b			inc 	1+(Pctr)
.116d					nocarry:
.116d	60		rts				rts

;******  Return to file: runtime.asm

.116e					EndRunPCode:
.116e					RuntimeEnd:
>116e	00 00						.word 	0 							; end marker for dictionary.

;******  End of listing
