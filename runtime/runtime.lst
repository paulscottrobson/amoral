
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -D test=1 --m6502 -o runtime.prg -L runtime.lst runtime.asm
; Sat Nov 14 06:07:37 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					test=1

;******  Processing input file: runtime.asm


;******  Processing file: macros.asm


;******  Return to file: runtime.asm

=$1000					RunTimeAddress = $1000 						; Runtime loads at this address (e.g. Boot)
=$c00					VariableMemory = $C00 						; Variable memory here (128 per 1/4k) PAGE BOUNDARY.
=$08					ZeroPageBase = $08 							; Zero page goes here.
=$08					Reg16 = ZeroPageBase 						; the current value register.
=10					Pctr = ZeroPageBase+2 						; the program counter (e.g. the next instruction)
=12					temp0 = ZeroPageBase+4 						; temporary registers
.1000	4c 70 11	jmp $1170			jmp 	TestRuntimeCode
>101a	00 10						.word 	RunTimeAddress 				; the address of boot
>101c	82 11						.word	RunTimeEnd 					; where the runtime ends (e.g. where code goes)
>101e	00 00						.word 	$0000 						; address of allocatable memory (set up by compiler)

;******  Processing file: interpreter.asm

>1020	62 01					.word 	EndRunPCode-* 							; offset to next entry
>1022	72 75 6e 70 63 6f 64 65			.text 	"runpcode",0 							; the text (must be lower case)
>102a	00
>102b						.align 	2								; force to even boundary.
.102c					RunPCode:
.102c	86 09		stx $09				stx 	Reg16+1 					; save the current XA values.
.102e	85 08		sta $08				sta 	Reg16
.1030	68		pla				pla 								; pull the address into the PC
.1031	85 0a		sta $0a				sta 	Pctr
.1033	68		pla				pla
.1034	85 0b		sta $0b				sta 	Pctr+1
.1036	e6 0a		inc $0a			inc 	Pctr
.1038	d0 02		bne $103c		bne 	nocarry
.103a	e6 0b		inc $0b			inc 	1+(Pctr)
.103c					nocarry:
.103c					ExecLoop:
>103c	db					.byte 	$DB
.103d	a0 00		ldy #$00			ldy 	#0							; get the next instruction
.103f	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1041	e6 0a		inc $0a			inc 	Pctr
.1043	d0 02		bne $1047		bne 	nocarry
.1045	e6 0b		inc $0b			inc 	1+(Pctr)
.1047					nocarry:
.1047	0a		asl a				asl 	a 							; shift bit 7 into carry.
.1048	b0 29		bcs $1073			bcs 	CommandHandler 				; 80-FF it's a command
.104a	85 0c		sta $0c				sta 	temp0 						; construct the call address in temp0
.104c	b1 0a		lda ($0a),y			lda 	(PCtr),y 					; get the MSB
.104e	85 0d		sta $0d				sta 	temp0+1
.1050	e6 0a		inc $0a			inc 	Pctr
.1052	d0 02		bne $1056		bne 	nocarry
.1054	e6 0b		inc $0b			inc 	1+(Pctr)
.1056					nocarry:
.1056	a5 0a		lda $0a				lda 	Pctr 						; save PCTR on 6502 stack
.1058	48		pha				pha
.1059	a5 0b		lda $0b				lda 	Pctr+1
.105b	48		pha				pha
.105c	a5 08		lda $08				lda 	Reg16 						; restore Reg16 into XA
.105e	a6 09		ldx $09				ldx 	Reg16+1
.1060	20 70 10	jsr $1070			jsr 	CallTemp0 					; call the routine as 6502 code.
.1063	86 09		stx $09				stx 	Reg16+1 					; save Reg16 back
.1065	85 08		sta $08				sta 	Reg16
.1067	68		pla				pla 								; restore the program counter
.1068	85 0b		sta $0b				sta 	Pctr+1
.106a	68		pla				pla
.106b	85 0a		sta $0a				sta 	Pctr
.106d	4c 3c 10	jmp $103c			jmp 	ExecLoop 					; and go round again.
.1070					CallTemp0:
.1070	6c 0c 00	jmp ($000c)			jmp 	(temp0)
.1073					CommandHandler:
.1073	6a		ror a				ror 	a 							; patch it back so it has the full opcode.
.1074	a8		tay				tay  								; save it in Y for use by the commands.
.1075	c9 f0		cmp #$f0			cmp 	#$F0 						; is it a unary operation.
.1077	b0 05		bcs $107e			bcs 	_CHIsUnary
.1079	29 0f		and #$0f			and 	#$0F 						; get the command number out.
.107b	4c 82 10	jmp $1082			jmp 	_CHCall 					; go do the call
.107e					_CHIsUnary:
.107e	29 0f		and #$0f			and 	#$0F 						; this is the unary command number
.1080	09 10		ora #$10			ora 	#$10 						; mapped onto $10-$1F
.1082					_CHCall:
.1082	0a		asl a				asl 	a 							; now offset in the jump table and into X
.1083	aa		tax				tax
.1084	bd 94 10	lda $1094,x			lda 	JumpTable,x 				; copy the jump table vectors into temp0
.1087	85 0c		sta $0c				sta 	temp0
.1089	bd 95 10	lda $1095,x			lda 	JumpTable+1,x
.108c	85 0d		sta $0d				sta 	temp0+1
.108e	6c 0c 00	jmp ($000c)			jmp 	(temp0)						; and go there to execute with the opcode in Y.
.1091					OpcodeError:
.1091	a2 ee		ldx #$ee			ldx 	#$EE 						; EE = Error :)
>1093	db					.byte 	$DB
.1094					JumpTable:

;******  Processing file: generated/jumptable.inc

>1094	d4 10					.word LoadHandler              ; $80 LDR
>1096	91 10					.word OpcodeError              ; $81 ?
>1098	91 10					.word OpcodeError              ; $82 ?
>109a	91 10					.word OpcodeError              ; $83 ?
>109c	91 10					.word OpcodeError              ; $84 ?
>109e	91 10					.word OpcodeError              ; $85 ?
>10a0	91 10					.word OpcodeError              ; $86 ?
>10a2	91 10					.word OpcodeError              ; $87 ?
>10a4	91 10					.word OpcodeError              ; $88 ?
>10a6	91 10					.word OpcodeError              ; $89 ?
>10a8	e2 10					.word StoreHandler             ; $8a STR
>10aa	91 10					.word OpcodeError              ; $8b ?
>10ac	91 10					.word OpcodeError              ; $8c ?
>10ae	91 10					.word OpcodeError              ; $8d ?
>10b0	91 10					.word OpcodeError              ; $8e ?
>10b2	91 10					.word OpcodeError              ; $8f ?
>10b4	91 10					.word OpcodeError              ; $f0 ?
>10b6	91 10					.word OpcodeError              ; $f1 ?
>10b8	91 10					.word OpcodeError              ; $f2 ?
>10ba	91 10					.word OpcodeError              ; $f3 ?
>10bc	91 10					.word OpcodeError              ; $f4 ?
>10be	91 10					.word OpcodeError              ; $f5 ?
>10c0	91 10					.word OpcodeError              ; $f6 ?
>10c2	91 10					.word OpcodeError              ; $f7 ?
>10c4	91 10					.word OpcodeError              ; $f8 ?
>10c6	91 10					.word OpcodeError              ; $f9 ?
>10c8	91 10					.word OpcodeError              ; $fa ?
>10ca	91 10					.word OpcodeError              ; $fb ?
>10cc	91 10					.word OpcodeError              ; $fc ?
>10ce	91 10					.word OpcodeError              ; $fd ?
>10d0	91 10					.word OpcodeError              ; $fe ?
>10d2	91 10					.word OpcodeError              ; $ff ?

;******  Return to file: interpreter.asm


;******  Return to file: runtime.asm


;******  Processing file: commands.asm

.10d4					LoadHandler:
.10d4	20 f3 10	jsr $10f3			jsr 	EvaluateValue 				; temp0 = target value.
.10d7	a5 0c		lda $0c				lda 	temp0						; copy value into register
.10d9	85 08		sta $08				sta 	Reg16
.10db	a5 0d		lda $0d				lda 	temp0+1
.10dd	85 09		sta $09				sta 	Reg16+1
.10df	4c 3c 10	jmp $103c			jmp 	ExecLoop
.10e2					StoreHandler:
.10e2	20 28 11	jsr $1128			jsr 	EvaluateAddress 			; temp0 = target address.
.10e5	a0 00		ldy #$00			ldy 	#0							; write register out
.10e7	a5 08		lda $08				lda 	Reg16
.10e9	91 0c		sta ($0c),y			sta 	(temp0),y
.10eb	a5 09		lda $09				lda 	Reg16+1
.10ed	c8		iny				iny
.10ee	91 0c		sta ($0c),y			sta 	(temp0),y
.10f0	4c 3c 10	jmp $103c			jmp 	ExecLoop

;******  Return to file: runtime.asm


;******  Processing file: support.asm

.10f3					EvaluateValue:
.10f3	98		tya				tya 								; get EAC part and save in X
.10f4	29 70		and #$70			and 	#$70
.10f6	aa		tax				tax
.10f7	c9 20		cmp #$20			cmp 	#$20 						; check if 00,01 if so it is variable or absolute
.10f9	b0 1d		bcs $1118			bcs 	_EDMemory
.10fb	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.10fd	b1 0a		lda ($0a),y			lda 	(Pctr),y
.10ff	85 0c		sta $0c				sta 	temp0
.1101	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1103	e6 0a		inc $0a			inc 	Pctr
.1105	d0 02		bne $1109		bne 	nocarry
.1107	e6 0b		inc $0b			inc 	1+(Pctr)
.1109					nocarry:
.1109	e0 00		cpx #$00			cpx 	#0 							; if it is 000 then it is a one byte
.110b	f0 0a		beq $1117			beq 	_EACalcValue
.110d	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.110f	85 0d		sta $0d				sta 	temp0+1
.1111	e6 0a		inc $0a			inc 	Pctr
.1113	d0 02		bne $1117		bne 	nocarry
.1115	e6 0b		inc $0b			inc 	1+(Pctr)
.1117					nocarry:
.1117					_EACalcValue:
.1117	60		rts				rts
.1118					_EDMemory:
.1118	20 28 11	jsr $1128			jsr	 	EvaluateAddress 			; evaluate the address.
.111b	a0 00		ldy #$00			ldy 	#0 							; 16 bit load indirect (temp0) => temp0
.111d	b1 0c		lda ($0c),y			lda 	(temp0),y
.111f	aa		tax				tax
.1120	c8		iny				iny
.1121	b1 0c		lda ($0c),y			lda 	(temp0),y
.1123	86 0c		stx $0c				stx 	temp0
.1125	85 0d		sta $0d				sta 	temp0+1
.1127	60		rts				rts
.1128					EvaluateAddress:
.1128	98		tya				tya 								; get EAC part of opcode.
.1129	29 70		and #$70			and 	#$70
.112b	c9 40		cmp #$40			cmp 	#$40 						; is it an absolute address
.112d	f0 29		beq $1158			beq 	_EAAbsolute
.112f	aa		tax				tax 								; save in X
.1130	a0 00		ldy #$00			ldy 	#0 							; read first byte into temp0
.1132	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1134	85 0c		sta $0c				sta 	temp0
.1136	84 0d		sty $0d				sty 	temp0+1 					; make it 16 bit.
.1138	e6 0a		inc $0a			inc 	Pctr
.113a	d0 02		bne $113e		bne 	nocarry
.113c	e6 0b		inc $0b			inc 	1+(Pctr)
.113e					nocarry:
.113e	e0 20		cpx #$20			cpx 	#$20 						; if it is 010 then it is a one byte
.1140	f0 0a		beq $114c			beq 	_EACalcVarAddress
.1142	b1 0a		lda ($0a),y			lda 	(Pctr),y 					; read 2nd byte into temp0+1
.1144	85 0d		sta $0d				sta 	temp0+1
.1146	e6 0a		inc $0a			inc 	Pctr
.1148	d0 02		bne $114c		bne 	nocarry
.114a	e6 0b		inc $0b			inc 	1+(Pctr)
.114c					nocarry:
.114c					_EACalcVarAddress:
.114c	06 0c		asl $0c				asl 	temp0 						; double the variable number
.114e	26 0d		rol $0d				rol 	temp0+1
.1150	18		clc				clc 								; add the page address of variable data on.
.1151	a5 0d		lda $0d				lda 	temp0+1
.1153	69 0c		adc #$0c			adc 	#VariableMemory/256
.1155	85 0d		sta $0d				sta 	temp0+1
.1157	60		rts				rts
.1158					_EAAbsolute:
.1158	a0 00		ldy #$00			ldy 	#0 							; get the address into temp0
.115a	b1 0a		lda ($0a),y			lda 	(Pctr),y
.115c	85 0c		sta $0c				sta 	temp0
.115e	c8		iny				iny
.115f	b1 0a		lda ($0a),y			lda 	(Pctr),y
.1161	85 0d		sta $0d				sta 	temp0+1
.1163					ReturnBump2
.1163	e6 0a		inc $0a			inc 	Pctr
.1165	d0 02		bne $1169		bne 	nocarry
.1167	e6 0b		inc $0b			inc 	1+(Pctr)
.1169					nocarry:
.1169					ReturnBump1:
.1169	e6 0a		inc $0a			inc 	Pctr
.116b	d0 02		bne $116f		bne 	nocarry
.116d	e6 0b		inc $0b			inc 	1+(Pctr)
.116f					nocarry:
.116f	60		rts				rts

;******  Return to file: runtime.asm

.1170					TestRuntimeCode:
.1170	a2 ab		ldx #$ab			ldx 	#$AB 						; something to work with
.1172	a9 cd		lda #$cd			lda 	#$CD
.1174	20 2c 10	jsr $102c			jsr 	RunPCode 					; go do the following code.

;******  Processing file: generated/testasm.inc

.1177					TEST_count:
>1177	80 41					.byte $80,$41                                  ; ldr #65
>1179	aa 00					.byte $aa,$00                                  ; str [0]
>117b	90 ff 7f				.byte $90,$ff,$7f                              ; ldr #32767
>117e	aa 02					.byte $aa,$02                                  ; str [2]
>1180	ff					.byte $ff                                      ; halt

;******  Return to file: runtime.asm

>1181	db					.byte 	$DB
.1182					EndRunPCode:
.1182					RuntimeEnd:
>1182	00 00						.word 	0 							; end marker for dictionary.

;******  End of listing
